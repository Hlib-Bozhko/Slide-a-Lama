// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Data\Class1.cs ---


﻿namespace Data;

public class Class1
{
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Datas\Class1.cs ---


using System;

namespace Datas
{
    public class Class1
    {
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Datas\Entity\Comment.cs ---

using System;


[Serializable]
public class Comment
{
    public Guid Id { get; set; }
    public string Name { get; set; }
    public string Text { get; set; }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Datas\Entity\Rating.cs ---


using System;

public class Rating
{
    public Guid id { get; set; }
    public string Name { get; set; }
    public int mark { get; set; }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Datas\Entity\Score.cs ---


using System;

namespace Datas.Entity
{
    [Serializable]
    public class Score
    {
        public Guid id { get; set; }
        public string Player { get; set; }
        public int Points { get; set; }

    }
}




// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Datas\Service\Slide-a-LamaDbContext.cs ---


using Microsoft.EntityFrameworkCore;
using Datas.Entity;

namespace Datas.Service
{
    public class SlideALamaDbContext : DbContext
    {
        public SlideALamaDbContext(DbContextOptions<SlideALamaDbContext> options) 
            : base(options)
        {
        }

        public DbSet<Score> Scores { get; set; }
        public DbSet<Comment> Comments { get; set; }
        public DbSet<Rating> Rating { get; set; }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);
            
            modelBuilder.Entity<Score>(entity =>
            {
                entity.HasKey(e => e.id);
                entity.Property(e => e.Player)
                    .IsRequired()
                    .HasMaxLength(100);
                entity.Property(e => e.Points)
                    .IsRequired();
                      
                entity.HasIndex(e => e.Points)
                    .HasDatabaseName("IX_Score_Points");
            });

            modelBuilder.Entity<Comment>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.Property(e => e.Name)
                    .IsRequired()
                    .HasMaxLength(100);
                entity.Property(e => e.Text)
                    .IsRequired()
                    .HasMaxLength(1000);
            });

            modelBuilder.Entity<Rating>(entity =>
            {
                entity.HasKey(e => e.id);
                entity.Property(e => e.Name)
                    .IsRequired()
                    .HasMaxLength(100);
                entity.Property(e => e.mark)
                    .IsRequired()
                    .HasAnnotation("Range", new[] { 0, 100 });
            });
        }
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Datas\Service\Comments\CommentServiceEF.cs ---


using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Datas.Entity;
using Datas.Service.Comments;

namespace Datas.Service.Comments
{
    public class CommentServiceEF : ICommentService
    {
        private readonly SlideALamaDbContext _context;
        private readonly ILogger<CommentServiceEF> _logger;

        public CommentServiceEF(SlideALamaDbContext context, ILogger<CommentServiceEF> logger)
        {
            _context = context ?? throw new ArgumentNullException(nameof(context));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public async Task AddCommentAsync(Comment comment)
        {
            try
            {
                if (comment == null)
                    throw new ArgumentNullException(nameof(comment));

                if (string.IsNullOrWhiteSpace(comment.Name))
                    throw new ArgumentException("Comment name cannot be empty", nameof(comment));

                if (string.IsNullOrWhiteSpace(comment.Text))
                    throw new ArgumentException("Comment text cannot be empty", nameof(comment));

                if (comment.Text.Length > 1000)
                    throw new ArgumentException("Comment text is too long (max 1000 characters)", nameof(comment));

                _context.Comments.Add(comment);
                await _context.SaveChangesAsync();
                
                _logger.LogInformation("Comment added by user {Name}: {Text}", 
                    comment.Name, comment.Text.Substring(0, Math.Min(50, comment.Text.Length)));
            }
            catch (DbUpdateException ex)
            {
                _logger.LogError(ex, "Database error while adding comment by user {Name}", comment?.Name);
                throw new InvalidOperationException("Failed to save comment to database", ex);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error while adding comment by user {Name}", comment?.Name);
                throw;
            }
        }

        public async Task<IList<Comment>> GetCommentsAsync()
        {
            try
            {
                var comments = await _context.Comments
                    .OrderByDescending(c => c.Text)
                    .ToListAsync();
                
                _logger.LogInformation("Retrieved {Count} comments", comments.Count);
                return comments;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving comments");
                throw new InvalidOperationException("Failed to retrieve comments", ex);
            }
        }

        public async Task ResetCommentsAsync()
        {
            try
            {
                var allComments = await _context.Comments.ToListAsync();
                _context.Comments.RemoveRange(allComments);
                await _context.SaveChangesAsync();
                
                _logger.LogWarning("All comments have been reset");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error resetting comments");
                throw new InvalidOperationException("Failed to reset comments", ex);
            }
        }

        // Synchronous methods for backwards compatibility
        public void AddComment(Comment comment)
        {
            AddCommentAsync(comment).GetAwaiter().GetResult();
        }

        public IList<Comment> GetComments()
        {
            return GetCommentsAsync().GetAwaiter().GetResult();
        }

        public void ResetComments()
        {
            ResetCommentsAsync().GetAwaiter().GetResult();
        }
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Datas\Service\Comments\ICommentService.cs ---


using System.Collections.Generic;
using System.Threading.Tasks;
using Datas.Entity;

namespace Datas.Service.Comments
{
    public interface ICommentService
    {
        // Async methods
        Task AddCommentAsync(Comment comment);
        Task<IList<Comment>> GetCommentsAsync();
        Task ResetCommentsAsync();

        // Standard methods 
        void AddComment(Comment comment);
        IList<Comment> GetComments();
        void ResetComments();
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Datas\Service\Rates\IRatingService.cs ---


using System.Collections.Generic;
using System.Threading.Tasks;
using Datas.Entity;

namespace Datas.Service.Rates
{
    public interface IRatingService
    {
        // Async methods
        Task AddRateAsync(Rating rating);
        Task<IList<Rating>> GetRatesAsync();
        Task ResetRatesAsync();

        // Standard methods (for backwards compatibility)
        void AddRate(Rating rating);
        IList<Rating> GetRates();
        void ResetRates();
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Datas\Service\Rates\RatingServiceEF.cs ---


using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Datas.Entity;
using Datas.Service.Rates;

namespace Datas.Service.Rates
{
    public class RatingServiceEF : IRatingService
    {
        private readonly SlideALamaDbContext _context;
        private readonly ILogger<RatingServiceEF> _logger;

        public RatingServiceEF(SlideALamaDbContext context, ILogger<RatingServiceEF> logger)
        {
            _context = context ?? throw new ArgumentNullException(nameof(context));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public async Task AddRateAsync(Rating rating)
        {
            try
            {
                if (rating == null)
                    throw new ArgumentNullException(nameof(rating));

                if (string.IsNullOrWhiteSpace(rating.Name))
                    throw new ArgumentException("Rating name cannot be empty", nameof(rating));

                if (rating.mark < 0 || rating.mark > 100)
                    throw new ArgumentException("Rating mark must be between 0 and 100", nameof(rating));

                _context.Rating.Add(rating);
                await _context.SaveChangesAsync();
                
                _logger.LogInformation("Rating added for user {Name} with mark {Mark}", 
                    rating.Name, rating.mark);
            }
            catch (DbUpdateException ex)
            {
                _logger.LogError(ex, "Database error while adding rating for user {Name}", rating?.Name);
                throw new InvalidOperationException("Failed to save rating to database", ex);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error while adding rating for user {Name}", rating?.Name);
                throw;
            }
        }

        public async Task<IList<Rating>> GetRatesAsync()
        {
            try
            {
                var ratings = await _context.Rating
                    .OrderByDescending(r => r.mark)
                    .ToListAsync();
                
                _logger.LogInformation("Retrieved {Count} ratings", ratings.Count);
                return ratings;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving ratings");
                throw new InvalidOperationException("Failed to retrieve ratings", ex);
            }
        }

        public async Task ResetRatesAsync()
        {
            try
            {
                var allRatings = await _context.Rating.ToListAsync();
                _context.Rating.RemoveRange(allRatings);
                await _context.SaveChangesAsync();
                
                _logger.LogWarning("All ratings have been reset");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error resetting ratings");
                throw new InvalidOperationException("Failed to reset ratings", ex);
            }
        }

        // Synchronous methods for backwards compatibility
        public void AddRate(Rating rating)
        {
            AddRateAsync(rating).GetAwaiter().GetResult();
        }

        public IList<Rating> GetRates()
        {
            return GetRatesAsync().GetAwaiter().GetResult();
        }

        public void ResetRates()
        {
            ResetRatesAsync().GetAwaiter().GetResult();
        }
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Datas\Service\Scores\IScoreService.cs ---


using System.Collections.Generic;
using System.Threading.Tasks;
using Datas.Entity;

namespace Datas.Service.Scores
{
    public interface IScoreService
    {
        // Async methods
        Task AddScoreAsync(Score score);
        Task<IList<Score>> GetTopScoresAsync(int count = 10);
        Task ResetScoreAsync();

        // Standard methods
        void AddScore(Score score);
        IList<Score> GetTopScores();
        void ResetScore();
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Datas\Service\Scores\ScoreServiceEF.cs ---


using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Datas.Entity;
using Datas.Service;
using Datas.Service.Scores;
using Microsoft.Extensions.Logging;

public class ScoreServiceEF : IScoreService
    {
        private readonly SlideALamaDbContext _context;
        private readonly ILogger<ScoreServiceEF> _logger;

        public ScoreServiceEF(SlideALamaDbContext context, ILogger<ScoreServiceEF> logger)
        {
            _context = context ?? throw new ArgumentNullException(nameof(context));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public async Task AddScoreAsync(Score score)
        {
            try
            {
                if (score == null)
                    throw new ArgumentNullException(nameof(score));

                if (string.IsNullOrWhiteSpace(score.Player))
                    throw new ArgumentException("Player name cannot be empty", nameof(score));

                if (score.Points < 0)
                    throw new ArgumentException("Points cannot be negative", nameof(score));

                _context.Scores.Add(score);
                await _context.SaveChangesAsync();
                
                _logger.LogInformation("Score added for player {Player} with {Points} points", 
                    score.Player, score.Points);
            }
            catch (DbUpdateException ex)
            {
                _logger.LogError(ex, "Database error while adding score for player {Player}", score?.Player);
                throw new InvalidOperationException("Failed to save score to database", ex);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error while adding score for player {Player}", score?.Player);
                throw;
            }
        }

        public async Task<IList<Score>> GetTopScoresAsync(int count = 10)
        {
            try
            {
                var scores = await _context.Scores
                    .OrderByDescending(s => s.Points)
                    .Take(count)
                    .ToListAsync();
                
                _logger.LogInformation("Retrieved {Count} top scores", scores.Count);
                return scores;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving top scores");
                throw new InvalidOperationException("Failed to retrieve top scores", ex);
            }
        }

        public async Task ResetScoreAsync()
        {
            try
            {
                var allScores = await _context.Scores.ToListAsync();
                _context.Scores.RemoveRange(allScores);
                await _context.SaveChangesAsync();
                
                _logger.LogWarning("All scores have been reset");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error resetting scores");
                throw new InvalidOperationException("Failed to reset scores", ex);
            }
        }

        public void AddScore(Score score)
        {
            AddScoreAsync(score).GetAwaiter().GetResult();
        }

        public IList<Score> GetTopScores()
        {
            return GetTopScoresAsync().GetAwaiter().GetResult();
        }

        public void ResetScore()
        {
            ResetScoreAsync().GetAwaiter().GetResult();
        }
    }






// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Datas\Service\Scores\ScoreServiceFile.cs ---


using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.Serialization.Formatters.Binary;
using System.Threading.Tasks;
using Datas.Entity;
using Datas.Service.Scores;

public class ScoreServiceFile : IScoreService
{
    private const string FileName = "score.bin";

    private IList<Score> _scores = new List<Score>();
    public async Task AddScoreAsync(Score score)
    {
        throw new System.NotImplementedException();
    }

    public async Task<IList<Score>> GetTopScoresAsync(int count = 10)
    {
        throw new System.NotImplementedException();
    }

    public async Task ResetScoreAsync()
    {
        throw new System.NotImplementedException();
    }

    void IScoreService.AddScore(Score score)
    {
        _scores.Add(score);
        SaveScores();
    }

    IList<Score> IScoreService.GetTopScores()
    {
        LoadScores();
        return (from s in _scores orderby s.Points descending select s).Take(5).ToList();
    }

    void IScoreService.ResetScore()
    {
        _scores.Clear();
        File.Delete(FileName);
    }

    private void SaveScores()
    {
        using (var fs = File.OpenWrite(FileName))
        {
            var bf = new BinaryFormatter();
            bf.Serialize(fs, _scores);
        }
    }

    private void LoadScores()
    {
        if (File.Exists(FileName))
        {
            using (var fs = File.OpenRead(FileName))
            {
                var bf = new BinaryFormatter();
                _scores = (List<Score>)bf.Deserialize(fs);
            }
        }
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide-a-Lama\Core\BoardManagement\CubeMovement.cs ---


// 4. CubeMovement.cs - Реализация движения кубиков
using System;

namespace Slide_a_Lama.Core
{
    [Serializable]
    public class CubeMovement : ICubeMovement
    {
        private readonly GameSettings _settings;
        
        public CubeMovement(GameSettings settings)
        {
            _settings = settings ?? throw new ArgumentNullException(nameof(settings));
        }
        
        public void MoveLeft(IGameBoard board, Position currentPosition)
        {
            if (!CanMoveLeft(currentPosition)) 
                return;

            ShiftRowLeft(board, currentPosition.Row);
        }

        public void MoveRight(IGameBoard board, Position currentPosition)
        {
            if (!CanMoveRight(currentPosition)) 
                return;

            ShiftRowRight(board, currentPosition.Row);
        }

        public void MoveDown(IGameBoard board, Position currentPosition)
        {
            if (!CanMoveDown(currentPosition)) 
                return;

            ShiftColumnDown(board, currentPosition.Column);
        }

        public void MoveUp(IGameBoard board, Position currentPosition)
        {
            if (!CanMoveUp(currentPosition)) 
                return;
                
            ShiftColumnUp(board, currentPosition.Column);
        }
        
        #region Movement capability checks
        
        private bool CanMoveLeft(Position position) => position.Row != -1 && position.Column > 0;
        private bool CanMoveRight(Position position) => position.Row != -1 && position.Column < _settings.ColumnCount - 1;
        private bool CanMoveDown(Position position) => position.Column != -1 && position.Row < _settings.RowCount - 1;
        private bool CanMoveUp(Position position) => position.Column != -1 && position.Row > 0;
        
        #endregion
        
        #region Row and column shifts
        
        private void ShiftRowLeft(IGameBoard board, int row)
        {
            if (row == -1) return;

            int firstColumn = 0;
            if (row != 0)
            {
                for (int i = _settings.ColumnCount - 1; i >= 1; i--)
                {
                    if (board.GetCube(new Position(row, i)).Value == 0)
                    {
                        firstColumn = i;
                    }
                }
            }

            for (int i = firstColumn; i < _settings.ColumnCount - 1; i++)
            {
                var currentCube = board.GetCube(new Position(row, i));
                var nextCube = board.GetCube(new Position(row, i + 1));
                currentCube.Value = nextCube.Value;
            }

            board.GetCube(new Position(row, _settings.ColumnCount - 1)).Value = 0;
            if (row != 0)
            {
                board.GetCube(new Position(row, 0)).Value = 0;
            }
        }

        private void ShiftRowRight(IGameBoard board, int row)
        {
            if (row == -1) return;

            int firstColumn = _settings.ColumnCount - 2;
            if (row != 0)
            {
                for (int i = 1; i < _settings.ColumnCount - 2; i++)
                {
                    if (board.GetCube(new Position(row, i)).Value == 0)
                    {
                        firstColumn = i - 1;
                    }
                }
            }

            for (int i = firstColumn; i >= 0; i--)
            {
                var targetCube = board.GetCube(new Position(row, i + 1));
                var sourceCube = board.GetCube(new Position(row, i));
                targetCube.Value = sourceCube.Value;
            }

            board.GetCube(new Position(row, 0)).Value = 0;
            if (row != 0)
            {
                board.GetCube(new Position(row, _settings.ColumnCount - 1)).Value = 0;
            }
        }

        private void ShiftColumnDown(IGameBoard board, int column)
        {
            if (column == -1) return;

            int firstRow = _settings.RowCount - 1;
            if (column != 0 && column != _settings.ColumnCount - 1)
            {
                for (int i = 1; i <= _settings.RowCount - 1; i++)
                {
                    if (board.GetCube(new Position(i, column)).Value == 0)
                    {
                        firstRow = i;
                    }
                }
            }

            for (int i = firstRow - 1; i >= 0; i--)
            {
                var targetCube = board.GetCube(new Position(i + 1, column));
                var sourceCube = board.GetCube(new Position(i, column));
                targetCube.Value = sourceCube.Value;
            }
            board.GetCube(new Position(0, column)).Value = 0;
        }

        private void ShiftColumnUp(IGameBoard board, int column)
        {
            if (column == -1) return;

            for (int i = 0; i < _settings.RowCount - 1; i++)
            {
                var targetCube = board.GetCube(new Position(i, column));
                var sourceCube = board.GetCube(new Position(i + 1, column));
                targetCube.Value = sourceCube.Value;
            }

            board.GetCube(new Position(_settings.RowCount - 1, column)).Value = 0;
        }
        
        #endregion
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide-a-Lama\Core\BoardManagement\GameBoard.cs ---


using System;
using System.Collections.Generic;

namespace Slide_a_Lama.Core
{
    [Serializable]
    public class GameBoard : IGameBoard
    {
        private readonly Cube[,] _cubes;
        
        public GameSettings Settings { get; }
        
        public GameBoard(GameSettings settings)
        {
            Settings = settings ?? throw new ArgumentNullException(nameof(settings));
            _cubes = new Cube[Settings.RowCount, Settings.ColumnCount];
        }
        
        #region Base operations with cubes
        
        public Cube GetCube(Position position)
        {
            if (!IsValidPosition(position))
                return null;
                
            if (_cubes[position.Row, position.Column] == null)
                _cubes[position.Row, position.Column] = new Cube(0);
                
            return _cubes[position.Row, position.Column];
        }
        
        public void SetCube(Position position, Cube cube)
        {
            if (IsValidPosition(position))
                _cubes[position.Row, position.Column] = cube;
        }
        
        public bool IsEmptyCell(Position position)
        {
            if (!IsValidPosition(position))
                return false;
                
            var cube = GetCube(position);
            return cube?.Value == 0;
        }
        
        #endregion
        
        #region Position validation
        
        public bool IsValidPosition(Position position)
        {
            return Settings.IsValidPosition(position);
        }
        
        public bool IsPlayablePosition(Position position)
        {
            return Settings.IsPlayablePosition(position);
        }
        
        public bool IsCornerPosition(Position position)
        {
            return Settings.IsCornerPosition(position);
        }
        
        public bool IsBorderPosition(Position position)
        {
            return Settings.IsBorderPosition(position);
        }
        
        public bool CanMoveTo(Position position)
        {
            if (!IsValidPosition(position))
                return false;
        
            if (!IsEmptyCell(position))
                return false;

            if (IsCornerPosition(position))
                return false;

            if (IsPlayablePosition(position))
                return true;
        
            if (IsBorderPosition(position))
                return true;
        
            return false;
        }
        
        #endregion
        
        #region Getting allowable moves
        
        public List<Position> GetValidMoves()
        {
            var validMoves = new List<Position>();
            
            for (int row = 0; row < Settings.RowCount; row++)
            {
                for (int column = 0; column < Settings.ColumnCount; column++)
                {
                    var position = new Position(row, column);
                    if (CanMoveTo(position))
                    {
                        validMoves.Add(position);
                    }
                }
            }
            
            return validMoves;
        }
        
        #endregion
        
        #region Utilities
        
        public void FillEmptyCells(IRandomGenerator randomGenerator)
        {
            for (int row = Settings.PlayableRowStart; row < Settings.PlayableRowEnd; row++)
            {
                for (int column = Settings.PlayableColumnStart; column < Settings.PlayableColumnEnd; column++)
                {
                    var position = new Position(row, column);
                    var cube = GetCube(position);
                    if (cube.Value == 0)
                    {
                        cube.Value = randomGenerator.Next(GameSettings.MinCubeValue, GameSettings.MaxCubeValue + 1);
                    }
                }
            }
        }
        
        public bool ValidateIntegrity()
        {
            for (int column = Settings.PlayableColumnStart; column < Settings.PlayableColumnEnd; column++)
            {
                bool foundEmpty = false;
                for (int row = Settings.RowCount - 1; row >= Settings.PlayableRowStart; row--)
                {
                    var cube = GetCube(new Position(row, column));
                    if (cube.Value == 0)
                    {
                        foundEmpty = true;
                    }
                    else if (foundEmpty)
                    {
                        // Found a cube over an empty space - violation of integrity
                        return false;
                    }
                }
            }
            return true;
        }
        
        public void DebugPrint()
        {
            Console.WriteLine("=== Game Board ===");
            for (int row = 0; row < Settings.RowCount; row++)
            {
                for (int column = 0; column < Settings.ColumnCount; column++)
                {
                    Console.Write(GetCube(new Position(row, column))?.Value ?? 0);
                    Console.Write(" ");
                }
                Console.WriteLine();
            }
            Console.WriteLine("==================");
        }
        
        #endregion
        
        #region Initialization
        
        public void Initialize(IRandomGenerator randomGenerator)
        {
            InitializeBorders();
            InitializePlayField(randomGenerator);
        }
        
        private void InitializeBorders()
        {
            for (int row = 0; row < Settings.RowCount; row++)
            {
                _cubes[row, 0] = new Cube(0);
                _cubes[row, Settings.ColumnCount - 1] = new Cube(0);
            }
            
            for (int column = 0; column < Settings.ColumnCount; column++)
            {
                _cubes[0, column] = new Cube(0);
            }
        }
        
        private void InitializePlayField(IRandomGenerator randomGenerator)
        {
            for (int row = Settings.PlayableRowStart; row < Settings.PlayableRowEnd; row++)
            {
                for (int column = Settings.PlayableColumnStart; column < Settings.PlayableColumnEnd; column++)
                {
                     var position = new Position(row, column);
                    _cubes[position.Row, position.Column] = new Cube(
                        randomGenerator.Next(GameSettings.MinCubeValue, GameSettings.MaxCubeValue + 1));
                }
            }
        }
        
        #endregion
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide-a-Lama\Core\GameLogic\FieldAdapter.cs ---


//Facade for a new architecture
using System;
using System.Collections.Generic;
using System.Linq;

namespace Slide_a_Lama.Core
{

    [Serializable]
    public class FieldAdapter
    {
        #region Private fields 
        
        private readonly IGame _game;
        private readonly GameSettings _settings;
        
        #endregion
        
        #region Public API 
        
        /// <summary>Player array</summary>
        public Player[] Players => _game.Players.ToArray();
        
        /// <summary>Current position of the active cube [row, column]</summary>
        public int[] CurrentCube => new[] { CurrentCubeRow, CurrentCubeColumn };
        
        /// <summary>Menu return flag</summary>
        public bool ToMenu { get; set; }
        
        /// <summary>Number of players</summary>
        public int PlayersCount => _game.Players.Count;
        
        /// <summary>Current player</summary>
        public Player CurrentPlayer => _game.CurrentPlayer;
        
        /// <summary>State of the game</summary>
        public GameState GameState => _game.GameState;
        
        /// <summary>Number of rows (including borders)</summary>
        public int RowCount => _settings.RowCount;
        
        /// <summary>Number of columns (including borders)</summary>
        public int ColumnCount => _settings.ColumnCount;
        
        // Auxiliary properties for CurrentCube
        private int CurrentCubeRow => _game.CurrentCubePosition.IsValid ? _game.CurrentCubePosition.Row : -1;
        private int CurrentCubeColumn => _game.CurrentCubePosition.IsValid ? _game.CurrentCubePosition.Column : -1;
        
        #endregion
        
        #region Конструкторы
        
        /// <summary>
        /// Main constructor 
        /// </summary>
        public FieldAdapter(int rowCount, int columnCount, int playersCount, int winScore)
        {
            _settings = new GameSettings(rowCount, columnCount, playersCount, winScore);
            _game = new Game(_settings);
        }
        
        /// <summary>
        /// Builder for dependency injection (for testing)
        /// </summary>
        internal FieldAdapter(IGame game, GameSettings settings)
        {
            _game = game ?? throw new ArgumentNullException(nameof(game));
            _settings = settings ?? throw new ArgumentNullException(nameof(settings));
        }
        
        #endregion
        
        #region Key game methods
        
        /// <summary>Add a new cube</summary>
        public void AddCube()
        {
            _game.AddCube();
        }
        
        /// <summary>Move the current cube to the position</summary>
        public void MoveCurCube(int row, int column)
        {
            var position = new Position(row, column);
            _game.MoveCurCube(position);
        }
        
        /// <summary>Place the cube (run physics)</summary>
        public void PutCube()
        {
            _game.PutCube();
        }
        
        /// <summary>Update the field (physics + combinations)</summary>
        public bool UpdateField()
        {
            return _game.UpdateField();
        }
        
        #endregion
        
        #region Methods of information
        
        /// <summary>Get the cube in position</summary>
        public Cube GetCube(int row, int column)
        {
            var position = new Position(row, column);
            return _game.GetCube(position);
        }
        
        /// <summary>Is there an active cube</summary>
        public bool HasActiveCube()
        {
            return _game.HasActiveCube();
        }
        
        /// <summary>Can the cube be moved to a position</summary>
        public bool CanMoveTo(int row, int column)
        {
            var position = new Position(row, column);
            return _game.CanMoveTo(position);
        }
        
        /// <summary>Can the current cube be placed</summary>
        public bool CanPutCube()
        {
            return _game.CanPutCube();
        }
        
        /// <summary>Get the player's current account</summary>
        public int GetScore()
        {
            return _game.GetScore();
        }
        
        /// <summary>Get the value of the current cube</summary>
        public int GetCurrentCubeValue()
        {
            return _game.GetCurrentCubeValue();
        }
        
        #endregion
        
        #region Utilitarian methods
        
        /// <summary>Force all the cubes down</summary>
        public void ForceDropAllCubes()
        {
            _game.ForceDropAllCubes();
        }
        
        /// <summary>Check the integrity of the field</summary>
        public bool ValidateFieldIntegrity()
        {
            return _game.ValidateFieldIntegrity();
        }
        
        /// <summary>Debugging field output to the console</summary>
        public void DebugPrintField()
        {
            _game.DebugPrintField();
        }
        
        /// <summary>Get the list of allowed moves</summary>
        public List<(int row, int column)> GetValidMoves()
        {
            var moves = _game.GetValidMoves();
            return moves.Select(move => (move.Row, move.Column)).ToList();
        }
        
        #endregion
        
        #region Movement methods (for ConsoleUi)
        
        /// <summary>Movement to the right</summary>
        public void MoveRight(int row)
        {
            if (row == -1) return;
            
            var currentColumn = CurrentCube[1];
            if (currentColumn >= 0 && currentColumn < ColumnCount - 1)
            {
                var newPosition = new Position(row, currentColumn + 1);
                if (_game.CanMoveTo(newPosition))
                {
                    _game.MoveCurCube(newPosition);
                }
            }
        }
        
        /// <summary>Movement to the left</summary>
        public void MoveLeft(int row)
        {
            if (row == -1) return;
            
            var currentColumn = CurrentCube[1];
            if (currentColumn > 0)
            {
                var newPosition = new Position(row, currentColumn - 1);
                if (_game.CanMoveTo(newPosition))
                {
                    _game.MoveCurCube(newPosition);
                }
            }
        }
        
        /// <summary>Downward movement</summary>
        public void MoveDown(int column)
        {
            if (column == -1) return;
            
            var currentRow = CurrentCube[0];
            if (currentRow >= 0 && currentRow < RowCount - 1)
            {
                var newPosition = new Position(currentRow + 1, column);
                if (_game.CanMoveTo(newPosition))
                {
                    _game.MoveCurCube(newPosition);
                }
            }
        }
        
        /// <summary>Upward movement</summary>
        public void MoveUp(int column)
        {
            if (column == -1) return;
            
            var currentRow = CurrentCube[0];
            if (currentRow > 0)
            {
                var newPosition = new Position(currentRow - 1, column);
                if (_game.CanMoveTo(newPosition))
                {
                    _game.MoveCurCube(newPosition);
                }
            }
        }
        
        #endregion
    }
    
    /// <summary>
    /// Factory for creating FieldAdapter
    /// </summary>
    public static class FieldAdapterFactory
    {
        /// <summary>
        /// Create a new game with standard components
        /// </summary>
        public static FieldAdapter CreateField(int rowCount, int columnCount, int playersCount, int winScore)
        {
            return new FieldAdapter(rowCount, columnCount, playersCount, winScore);
        }
        
        /// <summary>
        /// Create a game with implemented dependencies (for testing)
        /// </summary>
        internal static FieldAdapter CreateFieldWithDependencies(IGame game, GameSettings settings)
        {
            return new FieldAdapter(game, settings);
        }
        
        /// <summary>
        /// Create a game with default settings
        /// </summary>
        public static FieldAdapter CreateDefaultField()
        {
            return CreateField(8, 8, 2, 1000);
        }
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide-a-Lama\Core\GameLogic\Game.cs ---


// 2. Game.cs - Главный класс игры
using System;
using System.Collections.Generic;

namespace Slide_a_Lama.Core
{
    [Serializable]
    public class Game : IGame
    {
        #region Components
        
        private readonly GameSettings _settings;
        private readonly IGameBoard _board;
        private readonly IComboDetector _comboDetector;
        private readonly ICubePhysics _physics;
        private readonly IPlayerManager _playerManager;
        private readonly IActiveCubeManager _activeCubeManager;
        private readonly ICubeMovement _cubeMovement;
        private readonly IRandomGenerator _randomGenerator;
        
        #endregion
        
        #region Properties
        
        public GameState GameState { get; private set; }
        public GameSettings Settings => _settings;
        public Position CurrentCubePosition => _activeCubeManager.CurrentPosition;
        public Player CurrentPlayer => _playerManager.CurrentPlayer;
        public IReadOnlyList<Player> Players => _playerManager.Players;
        public bool ToMenu { get; set; }
        
        #endregion
        
        #region Constructor 
        
        public Game(int rowCount, int columnCount, int playersCount, int winScore)
            : this(new GameSettings(rowCount, columnCount, playersCount, winScore))
        {
        }
        
        public Game(GameSettings settings)
            : this(settings, new RandomGenerator())
        {
        }
        
        public Game(GameSettings settings, IRandomGenerator randomGenerator)
        {
            _settings = settings ?? throw new ArgumentNullException(nameof(settings));
            _randomGenerator = randomGenerator ?? throw new ArgumentNullException(nameof(randomGenerator));
            
            _board = new GameBoard(_settings);
            _comboDetector = new ComboDetector(_settings);
            _physics = new CubePhysics(_settings);
            _playerManager = new PlayerManager(_settings.PlayersCount);
            _activeCubeManager = new ActiveCubeManager(_settings);
            _cubeMovement = new CubeMovement(_settings);
            
            // Initialize the game
            Initialize();
        }
        
        // (for testing)
        public Game(
            GameSettings settings,
            IGameBoard board,
            IComboDetector comboDetector,
            ICubePhysics physics,
            IPlayerManager playerManager,
            IActiveCubeManager activeCubeManager,
            ICubeMovement cubeMovement,
            IRandomGenerator randomGenerator)
        {
            _settings = settings ?? throw new ArgumentNullException(nameof(settings));
            _board = board ?? throw new ArgumentNullException(nameof(board));
            _comboDetector = comboDetector ?? throw new ArgumentNullException(nameof(comboDetector));
            _physics = physics ?? throw new ArgumentNullException(nameof(physics));
            _playerManager = playerManager ?? throw new ArgumentNullException(nameof(playerManager));
            _activeCubeManager = activeCubeManager ?? throw new ArgumentNullException(nameof(activeCubeManager));
            _cubeMovement = cubeMovement ?? throw new ArgumentNullException(nameof(cubeMovement));
            _randomGenerator = randomGenerator ?? throw new ArgumentNullException(nameof(randomGenerator));
            
            GameState = GameState.PLAYING;
        }
        
        #endregion
        
        #region Main game actions
        
        public void AddCube()
        {
            if (_activeCubeManager.HasActiveCube)
            {
                _playerManager.SwitchToNextPlayer();
            }

            _activeCubeManager.AddNewCube(_board, _randomGenerator);
            _playerManager.AddTurn();
        }
        
        public bool MoveCurCube(Position newPosition)
        {
            return _activeCubeManager.MoveTo(_board, newPosition);
        }
        
        public void PutCube()
        {
            _activeCubeManager.PutCube(_board, _cubeMovement);
        }
        
        public bool UpdateField()
        {
            bool hasChanges = false;
            
            for (int i = 0; i < GameSettings.MaxIterations; i++)
            {
                bool iterationHadChanges = false;
                
                // dropping all the cubes
                bool cubesDropped = _physics.DropAllCubes(_board);
                if (cubesDropped)
                {
                    iterationHadChanges = true;
                }
                
                // find and delete combinations
                var combo = _comboDetector.FindAndRemoveCombo(_board);
                if (combo.Found)
                {
                    iterationHadChanges = true;
                    hasChanges = true;
                    ProcessCombo(combo);
                }
                
                if (!iterationHadChanges)
                    break;
            }

            return hasChanges;
        }
        
        #endregion
        
        #region Utilities
        
        public Cube GetCube(Position position)
        {
            return _board.GetCube(position);
        }
        
        public int GetScore()
        {
            return _playerManager.GetCurrentScore();
        }
        
        public bool HasActiveCube()
        {
            if (!_activeCubeManager.HasActiveCube)
                return false;
                
            var cube = _board.GetCube(_activeCubeManager.CurrentPosition);
            return cube?.Value > 0;
        }
        
        public int GetCurrentCubeValue()
        {
            if (!_activeCubeManager.HasActiveCube)
                return 0;
                
            var cube = _board.GetCube(_activeCubeManager.CurrentPosition);
            return cube?.Value ?? 0;
        }
        
        public bool CanMoveTo(Position position)
        {
            return _board.CanMoveTo(position);
        }
        
        public bool CanPutCube()
        {
            return _activeCubeManager.CanPutCube(_board);
        }
        
        public List<Position> GetValidMoves()
        {
            return _board.GetValidMoves();
        }
        
        #endregion
        
        #region Debugging and diagnostics
        
        public void DebugPrintField()
        {
            _board.DebugPrint();
            Console.WriteLine("Current Cube: {0} = {1}", 
                CurrentCubePosition, GetCurrentCubeValue());
            Console.WriteLine("Current Player: {0}, Score: {1}", 
                CurrentPlayer.Team, GetScore());
            Console.WriteLine("---");
        }
        
        public bool ValidateFieldIntegrity()
        {
            return _board.ValidateIntegrity();
        }
        
        public void ForceDropAllCubes()
        {
            _physics.ForceDropAllCubes(_board);
        }
        
        #endregion
        
        #region Private methods
        
        private void Initialize()
        {
            _board.Initialize(_randomGenerator);
            GameState = GameState.PLAYING;
            
            StabilizeField();
            _playerManager.ResetCurrentPlayerStats();
        }
        
        private void StabilizeField()
        {
            while (UpdateField())
            {
                _board.FillEmptyCells(_randomGenerator);
            }
        }
        
        private void ProcessCombo(ComboResult combo)
        {
            int points = combo.Value * GameSettings.ComboMultiplier;
            _playerManager.AddScore(points);

            if (_playerManager.CheckWinCondition(_settings.WinScore))
            {
                GameState = GameState.WIN;
            }
        }
        
        #endregion
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide-a-Lama\Core\GameLogic\GameSettings.cs ---


// 2. GameSettings.cs - Настройки игры
using System;

namespace Slide_a_Lama.Core
{
    [Serializable]
    public class GameSettings
    {
        public const int MaxIterations = 50;
        public const int MaxCubeValue = 6;
        public const int MinCubeValue = 1;
        public const int TurnPenalty = 5;
        public const int ComboMultiplier = 10;
        
        // The main parameters of the game
        public int OriginalRowCount { get; }
        public int OriginalColumnCount { get; }
        public int PlayersCount { get; }
        public int WinScore { get; }
        
        // field parameters 
        public int RowCount { get; }
        public int ColumnCount { get; }
        
        public int PlayableRowStart { get; }
        public int PlayableRowEnd { get; }
        public int PlayableColumnStart { get; }
        public int PlayableColumnEnd { get; }
        
        public GameSettings(int rowCount, int columnCount, int playersCount, int winScore)
        {
            if (rowCount <= 0 || columnCount <= 0 || playersCount <= 0 || winScore <= 0)
                throw new ArgumentException("All parameters must be positive");
                
            OriginalRowCount = rowCount;
            OriginalColumnCount = columnCount;
            PlayersCount = playersCount;
            WinScore = winScore;
            
            ColumnCount = columnCount + 2; 
            RowCount = rowCount + 1; 
            
            PlayableRowStart = 1;
            PlayableRowEnd = RowCount; 
            PlayableColumnStart = 1;
            PlayableColumnEnd = ColumnCount - 1;
        }
        
        public bool IsValidPosition(Position position)
        {
            return position.Row >= 0 && position.Row < RowCount && 
                   position.Column >= 0 && position.Column < ColumnCount;
        }
        
        public bool IsPlayablePosition(Position position)
        {
            return position.Row >= PlayableRowStart && position.Row < PlayableRowEnd && 
                   position.Column >= PlayableColumnStart && position.Column < PlayableColumnEnd;
        }
        
        public bool IsCornerPosition(Position position)
        {
            return (position.Row == 0 && position.Column == 0) ||                           // Левый верхний угол
                   (position.Row == 0 && position.Column == ColumnCount - 1) ||             // Правый верхний угол
                   (position.Row == RowCount - 1 && position.Column == 0) ||                // Левый нижний угол  
                   (position.Row == RowCount - 1 && position.Column == ColumnCount - 1);    // Правый нижний угол
        }
        
        public bool IsBorderPosition(Position position)
        {
            if (IsCornerPosition(position))
                return false;
        
            return (position.Row == 0) || 
                   (position.Column == 0) || 
                   (position.Column == ColumnCount - 1); 
        }
        
        public Position GetCenterPosition()
        {
            return new Position(0, (ColumnCount - 1) / 2);
        }
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide-a-Lama\Core\GameMechanics\ComboDetector.cs ---


// 3. ComboDetector.cs - Реализация поиска комбинаций
using System;

namespace Slide_a_Lama.Core
{
    [Serializable]
    public class ComboDetector : IComboDetector
    {
        private readonly GameSettings _settings;
        
        public ComboDetector(GameSettings settings)
        {
            _settings = settings ?? throw new ArgumentNullException(nameof(settings));
        }
        
        public ComboResult FindAndRemoveCombo(IGameBoard board)
        {
            var combo = FindCombo(board);
            if (combo.Found)
            {
                RemoveCombo(board, combo);
            }
            return combo;
        }
        
        public ComboResult FindCombo(IGameBoard board)
        {
            // Vertical combinations first
            var verticalCombo = FindVerticalCombo(board);
            if (verticalCombo.Found)
                return verticalCombo;
                
            // Horizontal combinations
            var horizontalCombo = FindHorizontalCombo(board);
            if (horizontalCombo.Found)
                return horizontalCombo;
                
            return ComboResult.NotFound;
        }
        
        public void RemoveCombo(IGameBoard board, ComboResult combo)
        {
            if (!combo.Found)
                return;
                
            foreach (var position in combo.Positions)
            {
                var cube = board.GetCube(position);
                if (cube != null)
                    cube.Value = 0;
            }
        }
        
        public bool HasPotentialCombos(IGameBoard board)
        {
            return FindCombo(board).Found;
        }
        
        #region Search of vertical combinations
        
        private ComboResult FindVerticalCombo(IGameBoard board)
        {
            for (int row = _settings.PlayableRowStart; row <= _settings.RowCount - 3; row++)
            {
                for (int column = _settings.PlayableColumnStart; column < _settings.PlayableColumnEnd; column++)
                {
                    var pos1 = new Position(row, column);
                    var pos2 = new Position(row + 1, column);
                    var pos3 = new Position(row + 2, column);
                    
                    var cube1 = board.GetCube(pos1);
                    var cube2 = board.GetCube(pos2);
                    var cube3 = board.GetCube(pos3);
                    
                    if (IsValidCombo(cube1, cube2, cube3))
                    {
                        return ComboResult.Create(cube1.Value, ComboType.Vertical, pos1, pos2, pos3);
                    }
                }
            }
            
            return ComboResult.NotFound;
        }
        
        #endregion
        
        #region Search of horizontal combinations
        
        private ComboResult FindHorizontalCombo(IGameBoard board)
        {
            // Проверяем горизонтальные комбинации правильно
            for (int row = _settings.PlayableRowStart; row < _settings.PlayableRowEnd; row++)
            {
                for (int column = _settings.PlayableColumnStart; column <= _settings.PlayableColumnEnd - 3; column++)
                {
                    var pos1 = new Position(row, column);
                    var pos2 = new Position(row, column + 1);
                    var pos3 = new Position(row, column + 2);
                    
                    var cube1 = board.GetCube(pos1);
                    var cube2 = board.GetCube(pos2);
                    var cube3 = board.GetCube(pos3);
                    
                    if (IsValidCombo(cube1, cube2, cube3))
                    {
                        return ComboResult.Create(cube1.Value, ComboType.Horizontal, pos1, pos2, pos3);
                    }
                }
            }
            
            return ComboResult.NotFound;
        }
        
        #endregion
        
        #region Auxiliary methods
        
        private static bool IsValidCombo(Cube cube1, Cube cube2, Cube cube3)
        {
            if (cube1 == null || cube2 == null || cube3 == null)
                return false;
                
            return cube1.Value != 0 && 
                   cube1.Value == cube2.Value && 
                   cube2.Value == cube3.Value;
        }
        
        #endregion
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide-a-Lama\Core\GameMechanics\CubePhysics.cs ---


using System;

namespace Slide_a_Lama.Core
{
    [Serializable]
    public class CubePhysics : ICubePhysics
    {
        private readonly GameSettings _settings;
        
        public CubePhysics(GameSettings settings)
        {
            _settings = settings ?? throw new ArgumentNullException(nameof(settings));
        }
        
        public virtual bool DropAllCubes(IGameBoard board) 
        {
            bool anyMoved = false;

            for (int column = _settings.PlayableColumnStart; column < _settings.PlayableColumnEnd; column++)
            {
                if (DropCubesInColumn(board, column))
                    anyMoved = true;
            }

            return anyMoved;
        }
        
        public bool DropCubesInColumn(IGameBoard board, int column)
        {
            bool hasMoved = false;
            
            int writePos = _settings.RowCount - 1; 
            
            for (int readPos = _settings.RowCount - 1; readPos >= _settings.PlayableRowStart; readPos--)
            {
                var readPosition = new Position(readPos, column);
                var cube = board.GetCube(readPosition);
                
                if (cube.Value != 0)
                {
                    if (readPos != writePos)
                    {
                        var writePosition = new Position(writePos, column);
                        var targetCube = board.GetCube(writePosition);
                        targetCube.Value = cube.Value;
                        cube.Value = 0;
                        hasMoved = true;
                    }
                    writePos--; 
                }
            }
            
            return hasMoved;
        }
        
        public void ForceDropAllCubes(IGameBoard board)
        {
            bool changed;
            int iterations = 0;
            const int maxIterations = 20;
            
            do
            {
                changed = DropAllCubes(board);
                iterations++;
            } while (changed && iterations < maxIterations);
        }
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide-a-Lama\Core\Infrastructure\RandomGenerator.cs ---


//To generate random numbers
using System;

namespace Slide_a_Lama.Core
{
    public interface IRandomGenerator
    {
        int Next(int minValue, int maxValue);
    }
    
    [Serializable]
    public class RandomGenerator : IRandomGenerator
    {
        [NonSerialized]
        private Random _random;
        
        public RandomGenerator()
        {
            EnsureInitialized();
        }
        
        public int Next(int minValue, int maxValue)
        {
            EnsureInitialized();
            return _random.Next(minValue, maxValue);
        }
        
        private void EnsureInitialized()
        {
            if (_random == null)
                _random = new Random();
        }
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide-a-Lama\Core\Interfaces\IActiveCubeManager.cs ---


// 1. IActiveCubeManager.cs - Интерфейс управления активным кубиком
namespace Slide_a_Lama.Core
{
    public interface IActiveCubeManager
    {
        Position CurrentPosition { get; }
        bool HasActiveCube { get; }
        // int CurrentCubeValue { get; }
        
        void AddNewCube(IGameBoard board, IRandomGenerator randomGenerator);
        bool MoveTo(IGameBoard board, Position newPosition);
        bool CanPutCube(IGameBoard board);
        void PutCube(IGameBoard board, ICubeMovement cubeMovement);
        void ResetPosition();
    }
}







// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide-a-Lama\Core\Interfaces\IComboDetector.cs ---


// 2. IComboDetector.cs - Интерфейс для поиска комбинаций
namespace Slide_a_Lama.Core
{
    public interface IComboDetector
    {
        ComboResult FindAndRemoveCombo(IGameBoard board);
        ComboResult FindCombo(IGameBoard board);
        void RemoveCombo(IGameBoard board, ComboResult combo);
        bool HasPotentialCombos(IGameBoard board);
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide-a-Lama\Core\Interfaces\ICubeMovement.cs ---


// 2. ICubeMovement.cs - Интерфейс для движения кубиков
namespace Slide_a_Lama.Core
{
    public interface ICubeMovement
    {
        void MoveLeft(IGameBoard board, Position currentPosition);
        void MoveRight(IGameBoard board, Position currentPosition);
        void MoveDown(IGameBoard board, Position currentPosition);
        void MoveUp(IGameBoard board, Position currentPosition);
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide-a-Lama\Core\Interfaces\ICubePhysics.cs ---


// 1. ICubePhysics.cs - Интерфейс физики кубиков
namespace Slide_a_Lama.Core
{
    public interface ICubePhysics
    {
        bool DropAllCubes(IGameBoard board);
        bool DropCubesInColumn(IGameBoard board, int column);
        void ForceDropAllCubes(IGameBoard board);
    }
}





// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide-a-Lama\Core\Interfaces\IGame.cs ---


// 1. IGame.cs - Интерфейс игры
using System.Collections.Generic;

namespace Slide_a_Lama.Core
{
    public interface IGame
    {
        // Свойства состояния игры
        GameState GameState { get; }
        GameSettings Settings { get; }
        Position CurrentCubePosition { get; }
        Player CurrentPlayer { get; }
        IReadOnlyList<Player> Players { get; }
        bool ToMenu { get; set; }
        
        // Основные игровые действия
        void AddCube();
        bool MoveCurCube(Position newPosition);
        void PutCube();
        bool UpdateField();
        
        // Утилиты
        Cube GetCube(Position position);
        int GetScore();
        bool HasActiveCube();
        int GetCurrentCubeValue();
        bool CanMoveTo(Position position);
        bool CanPutCube();
        List<Position> GetValidMoves();
        
        // Отладка и диагностика
        void DebugPrintField();
        bool ValidateFieldIntegrity();
        void ForceDropAllCubes();
    }
}





// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide-a-Lama\Core\Interfaces\IGameBoard.cs ---


// 1. IGameBoard.cs - Интерфейс игрового поля
using System.Collections.Generic;

namespace Slide_a_Lama.Core
{
    public interface IGameBoard
    {
        GameSettings Settings { get; }
        
        // Базовые операции с кубиками
        Cube GetCube(Position position);
        void SetCube(Position position, Cube cube);
        bool IsEmptyCell(Position position);
        
        // Валидация позиций
        bool IsValidPosition(Position position);
        bool IsPlayablePosition(Position position);
        bool IsCornerPosition(Position position);
        bool IsBorderPosition(Position position);
        
        // Получение допустимых ходов
        List<Position> GetValidMoves();
        bool CanMoveTo(Position position);
        
        // Утилиты
        void FillEmptyCells(IRandomGenerator randomGenerator);
        bool ValidateIntegrity();
        void DebugPrint();
        
        // Инициализация
        void Initialize(IRandomGenerator randomGenerator);
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide-a-Lama\Core\Interfaces\IPlayerManager.cs ---


// 1. IPlayerManager.cs - Интерфейс управления игроками
using System.Collections.Generic;

namespace Slide_a_Lama.Core
{
    public interface IPlayerManager
    {
        Player CurrentPlayer { get; }
        IReadOnlyList<Player> Players { get; }
        int PlayersCount { get; }
        
        void SwitchToNextPlayer();
        void AddScore(int points);
        void AddTurn();
        int GetCurrentScore();
        bool CheckWinCondition(int winScore);
        void ResetCurrentPlayerStats();
    }
}





// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide-a-Lama\Core\Legacy\Field.cs ---


using System;
using System.Collections.Generic;

namespace Slide_a_Lama.Core
{
    [Serializable]
    public class Field
    {
        private readonly Cube[,] _cubes;
        [NonSerialized]
        private Random _random;
        private readonly int _winScore;
        
        private readonly int _playableRowStart = 1;
        private readonly int _playableRowEnd;
        private readonly int _playableColumnStart = 1;
        private readonly int _playableColumnEnd;
        
        public readonly Player[] Players;
        public readonly int[] CurrentCube = {-1, -1};
        
        public bool ToMenu { get; set; }
        public int PlayersCount { get; }
        public Player CurrentPlayer { get; private set; }
        public GameState GameState { get; private set; }
        public int RowCount { get; }
        public int ColumnCount { get; }

        public Field(int rowCount, int columnCount, int playersCount, int winScore)
        {
            if (rowCount <= 0 || columnCount <= 0 || playersCount <= 0 || winScore <= 0)
                throw new ArgumentException("All parameters must be positive");

            ColumnCount = columnCount + 2; 
            RowCount = rowCount + 1; 
            PlayersCount = playersCount;
            _winScore = winScore;
            
            _playableRowEnd = RowCount;
            _playableColumnEnd = ColumnCount - 1;
            
            _cubes = new Cube[RowCount, ColumnCount];
            Players = new Player[playersCount];
            GameState = GameState.PLAYING;
            
            EnsureRandomInitialized();
            Initialize();
        }

        #region Public Methods

        public void MoveCurCube(int row, int column)
        {
            if (!IsValidPosition(row, column) || !IsEmptyCell(row, column))
                return;

            var currentCube = GetCurrentCube();
            if (currentCube == null || currentCube.Value == 0) 
                return;

            if (_cubes[row, column] == null)
                _cubes[row, column] = new Cube(0);

            _cubes[row, column].Value = currentCube.Value;
            currentCube.Value = 0;
            SetCurrentCubePosition(row, column);
        }

        public void PutCube()
        {
            var (row, column) = (CurrentCube[0], CurrentCube[1]);
            
            if (IsCornerPosition(row, column))
            {
                return; 
            }
            
            switch ((row, column))
            {
                case (0, _):
                    MoveDown(column);
                    break;
                case (_, 0) when row != 0:
                    MoveRight(row);
                    break;
                case var (r, c) when c == ColumnCount - 1 && r != 0:
                    MoveLeft(row);
                    break;
            }
        }

        public void AddCube()
        {
            EnsureRandomInitialized();
            
            if (CurrentCube[0] != -1)
            {
                SwitchToNextPlayer();
            }

            int centerColumn = (ColumnCount - 1) / 2;
            
            if (_cubes[0, centerColumn] == null)
                _cubes[0, centerColumn] = new Cube(0);
                
            _cubes[0, centerColumn].Value = _random.Next(1, 7);
            
            SetCurrentCubePosition(0, centerColumn);
            CurrentPlayer.Turns++;
        }

        public bool UpdateField()
        {
            const int maxIterations = 50;
            bool hasChanges = false;
            
            for (int i = 0; i < maxIterations; i++)
            {
                bool iterationHadChanges = false;
                
                bool cubesDropped = DropAllCubes();
                if (cubesDropped)
                {
                    iterationHadChanges = true;
                }
                
                bool comboFound = DelCombo();
                if (comboFound)
                {
                    iterationHadChanges = true;
                    hasChanges = true;
                }
                
                if (!iterationHadChanges)
                    break;
            }

            return hasChanges;
        }

        public Cube GetCube(int row, int column)
        {
            if (!IsValidPosition(row, column))
                return null;
                
            if (_cubes[row, column] == null)
                _cubes[row, column] = new Cube(0);
                
            return _cubes[row, column];
        }

        public int GetScore()
        {
            return Math.Max(0, CurrentPlayer.Score - CurrentPlayer.Turns * 5);
        }

        public bool HasActiveCube()
        {
            return CurrentCube[0] != -1 && CurrentCube[1] != -1 && 
                   IsValidPosition(CurrentCube[0], CurrentCube[1]) &&
                   GetCube(CurrentCube[0], CurrentCube[1])?.Value > 0;
        }

        public int GetCurrentCubeValue()
        {
            var cube = GetCurrentCube();
            return cube?.Value ?? 0;
        }

        public bool CanMoveTo(int row, int column)
        {
            if (!IsValidPosition(row, column) || !IsEmptyCell(row, column))
                return false;

            if (IsCornerPosition(row, column))
                return false;
            
            
            bool isInPlayableArea = IsValidPlayablePosition(row, column);
            bool isTopBorder = (row == 0 && column > 0 && column < ColumnCount - 1);
            bool isLeftBorder = (column == 0 && row > 0 && row < RowCount - 1);
            bool isRightBorder = (column == ColumnCount - 1 && row > 0 && row < RowCount - 1);
            
            return isInPlayableArea || isTopBorder || isLeftBorder || isRightBorder;
        }

        public bool CanPutCube()
        {
            var (row, column) = (CurrentCube[0], CurrentCube[1]);
            
            if (IsCornerPosition(row, column))
                return false;
                
            if (!HasActiveCube())
                return false;
                
            return (row == 0) || (column == 0 && row != 0) || (column == ColumnCount - 1 && row != 0);
        }

        public void DebugPrintField()
        {
            for (int row = 0; row < RowCount; row++)
            {
                for (int column = 0; column < ColumnCount; column++)
                {
                    Console.Write(GetCube(row, column)?.Value ?? 0);
                    Console.Write(" ");
                }
                Console.WriteLine();
            }
            Console.WriteLine("Current Cube: [{0},{1}] = {2}", 
                CurrentCube[0], CurrentCube[1], GetCurrentCubeValue());
            Console.WriteLine("---");
        }

        public bool ValidateFieldIntegrity()
        {
            for (int column = _playableColumnStart; column < _playableColumnEnd; column++)
            {
                bool foundEmpty = false;
                for (int row = RowCount - 1; row >= _playableRowStart; row--)
                {
                    var cube = GetCube(row, column);
                    if (cube.Value == 0)
                    {
                        foundEmpty = true;
                    }
                    else if (foundEmpty)
                    {
                        return false;
                    }
                }
            }
            return true;
        }

        public void ForceDropAllCubes()
        {
            bool changed;
            do
            {
                changed = DropAllCubes();
            } while (changed);
        }

        public List<(int row, int column)> GetValidMoves()
        {
            var validMoves = new List<(int row, int column)>();
            
            for (int row = 0; row < RowCount; row++)
            {
                for (int column = 0; column < ColumnCount; column++)
                {
                    if (CanMoveTo(row, column))
                    {
                        validMoves.Add((row, column));
                    }
                }
            }
            
            return validMoves;
        }

        #endregion

        #region Movement Methods

        public void MoveLeft(int row)
        {
            if (!CanMoveLeft(row)) return;

            CurrentCube[1]--;
            ShiftRowLeft(row);
        }

        public void MoveRight(int row)
        {
            if (!CanMoveRight(row)) return;

            CurrentCube[1]++;
            ShiftRowRight(row);
        }

        public void MoveDown(int column)
        {
            if (!CanMoveDown(column)) return;

            CurrentCube[0]++;
            ShiftColumnDown(column);
        }

        public void MoveUp(int column)
        {
            if (!CanMoveUp(column)) return;
                
            CurrentCube[0]--;
            ShiftColumnUp(column);
        }

        #endregion

        #region Private Methods - Initialization

        private void EnsureRandomInitialized()
        {
            if (_random == null)
                _random = new Random();
        }

        private void Initialize()
        {
            InitializeBorders();
            InitializePlayField();
            InitializePlayers();
            SetInitialPlayer();
            
            StabilizeField();
            ResetCurrentPlayerStats();
        }

        private void InitializePlayField()
        {
            EnsureRandomInitialized();
            
            for (int row = _playableRowStart; row < _playableRowEnd; row++)
            {
                for (int column = _playableColumnStart; column < _playableColumnEnd; column++)
                {
                    _cubes[row, column] = new Cube(_random.Next(1, 7));
                }
            }
        }

        private void InitializeBorders()
        {
            for (int row = 0; row < RowCount; row++)
            {
                _cubes[row, 0] = new Cube(0);
                _cubes[row, ColumnCount - 1] = new Cube(0);
            }
            
            for (int column = 0; column < ColumnCount; column++)
            {
                _cubes[0, column] = new Cube(0);
            }
        }

        private void InitializePlayers()
        {
            for (int i = 0; i < PlayersCount; i++)
            {
                Players[i] = new Player(i + 1);
            }
        }

        private void SetInitialPlayer()
        {
            CurrentPlayer = Players[0];
        }

        private void StabilizeField()
        {
            while (UpdateField())
            {
                FillEmptyCells();
            }
        }

        private void ResetCurrentPlayerStats()
        {
            CurrentPlayer.Score = 0;
            CurrentPlayer.Turns = 0;
        }

        #endregion

        #region Private Methods - Game logic

        private void SwitchToNextPlayer()
        {
            int currentIndex = CurrentPlayer.Team - 1;
            int nextIndex = (currentIndex + 1) % PlayersCount;
            CurrentPlayer = Players[nextIndex];
        }

        private void SetCurrentCubePosition(int row, int column)
        {
            CurrentCube[0] = row;
            CurrentCube[1] = column;
        }

        private Cube GetCurrentCube()
        {
            var (row, column) = (CurrentCube[0], CurrentCube[1]);
            return IsValidPosition(row, column) ? GetCube(row, column) : null;
        }

        #endregion

        #region Private Methods - Combinations 

        private bool DelCombo()
        {
            for (int iRow = _playableRowStart; iRow <= RowCount - 3; iRow++)
            {
                for (int iColumn = _playableColumnStart; iColumn < _playableColumnEnd; iColumn++)
                {
                    var cube1 = GetCube(iRow, iColumn);
                    var cube2 = GetCube(iRow + 1, iColumn);
                    var cube3 = GetCube(iRow + 2, iColumn);
                    
                    if (cube1.Value != 0 && cube1.Value == cube2.Value && cube2.Value == cube3.Value)
                    {
                        CheckState(cube1.Value);

                        cube1.Value = 0;
                        cube2.Value = 0;
                        cube3.Value = 0;
                        return true;
                    }
                }
            }

            for (int iRow = _playableRowStart; iRow < _playableRowEnd; iRow++)
            {
                for (int iColumn = _playableColumnStart; iColumn <= _playableColumnEnd - 3; iColumn++)
                {
                    var cube1 = GetCube(iRow, iColumn);
                    var cube2 = GetCube(iRow, iColumn + 1);
                    var cube3 = GetCube(iRow, iColumn + 2);
                    
                    if (cube1.Value != 0 && cube1.Value == cube2.Value && cube2.Value == cube3.Value)
                    {
                        CheckState(cube1.Value);

                        cube1.Value = 0;
                        cube2.Value = 0;
                        cube3.Value = 0;
                        return true;
                    }
                }
            }

            return false;
        }

        private void CheckState(int cubeValue)
        {
            CurrentPlayer.Score += cubeValue * 10;

            if (CurrentPlayer.Score >= _winScore)
            {
                GameState = GameState.WIN;
            }
        }

        #endregion

        #region Private Methods - Physics of fall 

        private bool DropAllCubes()
        {
            bool anyMoved = false;

            for (int column = _playableColumnStart; column < _playableColumnEnd; column++)
            {
                if (DropCubesInColumn(column))
                    anyMoved = true;
            }

            return anyMoved;
        }

        private bool DropCubesInColumn(int column)
        {
            bool hasMoved = false;
            
            int writePos = RowCount - 1; 
            
            for (int readPos = RowCount - 1; readPos >= _playableRowStart; readPos--)
            {
                var cube = GetCube(readPos, column);
                if (cube.Value != 0)
                {
                    if (readPos != writePos)
                    {
                        var targetCube = GetCube(writePos, column);
                        targetCube.Value = cube.Value;
                        cube.Value = 0;
                        hasMoved = true;
                    }
                    writePos--; 
                }
            }
            
            return hasMoved;
        }

        #endregion

        #region Private Methods - Movement

        private bool CanMoveLeft(int row) => row != -1 && CurrentCube[1] > 0;
        private bool CanMoveRight(int row) => row != -1 && CurrentCube[1] < ColumnCount - 1;
        private bool CanMoveDown(int column) => column != -1 && CurrentCube[0] < RowCount - 1;
        private bool CanMoveUp(int column) => column != -1 && CurrentCube[0] > 0;

        private void ShiftRowLeft(int row)
        {
            if (row == -1 || CurrentCube[1] == 0) return;

            int firstColumn = 0;
            if (row != 0)
            {
                for (int i = ColumnCount - 1; i >= 1; i--)
                {
                    if (GetCube(row, i).Value == 0)
                    {
                        firstColumn = i;
                    }
                }
            }

            for (int i = firstColumn; i < ColumnCount - 1; i++)
            {
                var currentCube = GetCube(row, i);
                var nextCube = GetCube(row, i + 1);
                currentCube.Value = nextCube.Value;
            }

            GetCube(row, ColumnCount - 1).Value = 0;
            if (row != 0)
            {
                GetCube(row, 0).Value = 0;
            }
        }

        private void ShiftRowRight(int row)
        {
            if (row == -1 || CurrentCube[1] == ColumnCount - 1) return;

            int firstColumn = ColumnCount - 2;
            if (row != 0)
            {
                for (int i = 1; i < ColumnCount - 2; i++)
                {
                    if (GetCube(row, i).Value == 0)
                    {
                        firstColumn = i - 1;
                    }
                }
            }

            for (int i = firstColumn; i >= 0; i--)
            {
                var targetCube = GetCube(row, i + 1);
                var sourceCube = GetCube(row, i);
                targetCube.Value = sourceCube.Value;
            }

            GetCube(row, 0).Value = 0;
            if (row != 0)
            {
                GetCube(row, ColumnCount - 1).Value = 0;
            }
        }

        private void ShiftColumnDown(int column)
        {
            if (column == -1 || CurrentCube[0] == RowCount - 1) return;

            int firstRow = RowCount - 1;
            if (column != 0 && column != ColumnCount - 1)
            {
                for (int i = 1; i <= RowCount - 1; i++)
                {
                    if (GetCube(i, column).Value == 0)
                    {
                        firstRow = i;
                    }
                }
            }

            for (int i = firstRow - 1; i >= 0; i--)
            {
                var targetCube = GetCube(i + 1, column);
                var sourceCube = GetCube(i, column);
                targetCube.Value = sourceCube.Value;
            }
            GetCube(0, column).Value = 0;
        }

        private void ShiftColumnUp(int column)
        {
            if (column == -1 || CurrentCube[0] == 0) return;

            for (int i = 0; i < RowCount - 1; i++)
            {
                var targetCube = GetCube(i, column);
                var sourceCube = GetCube(i + 1, column);
                targetCube.Value = sourceCube.Value;
            }

            GetCube(RowCount - 1, column).Value = 0;
        }

        #endregion

        #region Private Methods - Utilities

        private void FillEmptyCells()
        {
            EnsureRandomInitialized();
            
            for (int row = _playableRowStart; row < _playableRowEnd; row++)
            {
                for (int column = _playableColumnStart; column < _playableColumnEnd; column++)
                {
                    var cube = GetCube(row, column);
                    if (cube.Value == 0)
                    {
                        cube.Value = _random.Next(1, 7);
                    }
                }
            }
        }

        private bool IsValidPosition(int row, int column)
        {
            return row >= 0 && row < RowCount && column >= 0 && column < ColumnCount;
        }

        private bool IsValidPlayablePosition(int row, int column)
        {
            return row >= _playableRowStart && row < _playableRowEnd && 
                   column >= _playableColumnStart && column < _playableColumnEnd;
        }

        private bool IsEmptyCell(int row, int column)
        {
            if (!IsValidPosition(row, column))
                return false;
                
            var cube = GetCube(row, column);
            return cube?.Value == 0;
        }

        private bool IsCornerPosition(int row, int column)
        {
            return (row == 0 && column == 0) ||                           
                   (row == 0 && column == ColumnCount - 1) ||             
                   (row == RowCount - 1 && column == 0) ||                 
                   (row == RowCount - 1 && column == ColumnCount - 1);    
        }

        #endregion
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide-a-Lama\Core\Models\ComboResult.cs ---


// Combination search result
using System;
using System.Collections.Generic;

namespace Slide_a_Lama.Core
{
    [Serializable]
    public class ComboResult
    {
        public bool Found { get; set; }
        public int Value { get; set; }
        public List<Position> Positions { get; set; } = new();
        public ComboType Type { get; set; }
        
        public static ComboResult NotFound => new() { Found = false };
        
        public static ComboResult Create(int value, ComboType type, params Position[] positions)
        {
            return new ComboResult
            {
                Found = true,
                Value = value,
                Type = type,
                Positions = new List<Position>(positions)
            };
        }
    }
    
    [Serializable]
    public enum ComboType
    {
        Horizontal,
        Vertical
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide-a-Lama\Core\Models\Cube.cs ---


using System;

namespace Slide_a_Lama.Core
{
    [Serializable]
    public class Cube
    {

        public Cube(int value)
        {
            Value = value;
        }

        public int Value { get; set; }
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide-a-Lama\Core\Models\GameState.cs ---


using System;

namespace Slide_a_Lama
{
    [Serializable]
    public enum GameState
    {
        WIN,
        PLAYING
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide-a-Lama\Core\Models\Player.cs ---


using System;

namespace Slide_a_Lama.Core
{
    [Serializable]
    public class Player
    {
        public Player(int team)
        {
            Team = team;
            Score = 0;
            Turns = 0;
        }

        public int Score { get; set; }
        public int Team { get; }

        public int Turns { get; set; }
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide-a-Lama\Core\Models\Position.cs ---


// Structure for coordinates
using System;

namespace Slide_a_Lama.Core
{
    [Serializable]
    public readonly struct Position : IEquatable<Position>
    {
        public int Row { get; }
        public int Column { get; }
        
        public Position(int row, int column)
        {
            Row = row;
            Column = column;
        }
        
        public bool Equals(Position other)
        {
            return Row == other.Row && Column == other.Column;
        }
        
        public override bool Equals(object obj)
        {
            return obj is Position other && Equals(other);
        }
        
        public override int GetHashCode()
        {
            return HashCode.Combine(Row, Column);
        }
        
        public static bool operator ==(Position left, Position right)
        {
            return left.Equals(right);
        }
        
        public static bool operator !=(Position left, Position right)
        {
            return !left.Equals(right);
        }
        
        public override string ToString()
        {
            return $"({Row}, {Column})";
        }
        
        public static Position Invalid => new(-1, -1);
        
        public bool IsValid => Row >= 0 && Column >= 0;
    }
}







// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide-a-Lama\Core\PlayerManagement\ActiveCubeManager.cs ---


using System;

namespace Slide_a_Lama.Core
{
    [Serializable]
    public class ActiveCubeManager : IActiveCubeManager
    {
        private readonly GameSettings _settings;
        private Position _currentPosition;
        
        public Position CurrentPosition => _currentPosition;
        public bool HasActiveCube => _currentPosition.IsValid;
        
        // public int CurrentCubeValue
        // {
        //     get
        //     {
        //         return 0;
        //     }
        // }
        
        public ActiveCubeManager(GameSettings settings)
        {
            _settings = settings ?? throw new ArgumentNullException(nameof(settings));
            _currentPosition = Position.Invalid;
        }
        
        public void AddNewCube(IGameBoard board, IRandomGenerator randomGenerator)
        {
            var centerPosition = _settings.GetCenterPosition();
            
            var cube = board.GetCube(centerPosition);
            if (cube == null)
            {
                board.SetCube(centerPosition, new Cube(0));
                cube = board.GetCube(centerPosition);
            }
                
            cube.Value = randomGenerator.Next(GameSettings.MinCubeValue, GameSettings.MaxCubeValue + 1);
            _currentPosition = centerPosition;
        }
        
        public bool MoveTo(IGameBoard board, Position newPosition)
        {
            if (!HasActiveCube || !board.CanMoveTo(newPosition))
                return false;

            var currentCube = board.GetCube(_currentPosition);
            if (currentCube == null || currentCube.Value == 0) 
                return false;

            var targetCube = board.GetCube(newPosition);
            if (targetCube == null)
            {
                board.SetCube(newPosition, new Cube(0));
                targetCube = board.GetCube(newPosition);
            }

            targetCube.Value = currentCube.Value;
            currentCube.Value = 0;
            _currentPosition = newPosition;
            
            return true;
        }
        
        // Can be placed in borders (but not in corners)
        public bool CanPutCube(IGameBoard board)
        {
            if (!HasActiveCube)
                return false;
                
            var pos = _currentPosition;
            
            if (board.IsCornerPosition(pos))
                return false;
                
            return (pos.Row == 0) || 
                   (pos.Column == 0 && pos.Row != 0) || 
                   (pos.Column == _settings.ColumnCount - 1 && pos.Row != 0);
        }
        
        public void PutCube(IGameBoard board, ICubeMovement cubeMovement)
        {
            if (!CanPutCube(board))
                return;
                
            var pos = _currentPosition;
            
            if (board.IsCornerPosition(pos))
                return;
            
            switch ((pos.Row, pos.Column))
            {
                case (0, _):
                    cubeMovement.MoveDown(board, pos);
                    break;
                case (_, 0) when pos.Row != 0:
                    cubeMovement.MoveRight(board, pos);
                    break;
                case var (r, c) when c == _settings.ColumnCount - 1 && r != 0:
                    cubeMovement.MoveLeft(board, pos);
                    break;
            }
        }
        
        public void ResetPosition()
        {
            _currentPosition = Position.Invalid;
        }

        public void SetPositionForTesting(Position position)
        {
            _currentPosition = position;
        }
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide-a-Lama\Core\PlayerManagement\PlayerManager.cs ---


// 2. PlayerManager.cs - Реализация управления игроками
using System;
using System.Collections.Generic;
using System.Linq;

namespace Slide_a_Lama.Core
{
    [Serializable]
    public class PlayerManager : IPlayerManager
    {
        private readonly Player[] _players;
        private int _currentPlayerIndex;
        
        public Player CurrentPlayer => _players[_currentPlayerIndex];
        public IReadOnlyList<Player> Players => Array.AsReadOnly(_players);
        public int PlayersCount => _players.Length;
        
        public PlayerManager(int playersCount)
        {
            if (playersCount <= 0)
                throw new ArgumentException("Players count must be positive", nameof(playersCount));
                
            _players = new Player[playersCount];
            InitializePlayers();
            _currentPlayerIndex = 0;
        }
        
        public void SwitchToNextPlayer()
        {
            _currentPlayerIndex = (_currentPlayerIndex + 1) % PlayersCount;
        }
        
        public void AddScore(int points)
        {
            CurrentPlayer.Score += points;
        }
        
        public void AddTurn()
        {
            CurrentPlayer.Turns++;
        }
        
        public int GetCurrentScore()
        {
            return Math.Max(0, CurrentPlayer.Score - CurrentPlayer.Turns * GameSettings.TurnPenalty);
        }
        
        public bool CheckWinCondition(int winScore)
        {
            return CurrentPlayer.Score >= winScore;
        }
        
        public void ResetCurrentPlayerStats()
        {
            CurrentPlayer.Score = 0;
            CurrentPlayer.Turns = 0;
        }
        
        private void InitializePlayers()
        {
            for (int i = 0; i < PlayersCount; i++)
            {
                _players[i] = new Player(i + 1);
            }
        }
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide-a-Lama\UI\ConsoleUi.cs ---


using System;
using System.Threading;
using Slide_a_Lama.Core;
using Datas.Entity;
using Datas.Entity;
using Datas.Service;
using Datas.Service.Scores;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;

namespace Slide_a_Lama.UI
{
    internal class ConsoleUi
    {
        private static FieldAdapter _field;
        private static Menu _menu;
        public readonly IScoreService ScoreService;


        public ConsoleUi()
        {
            var options = new DbContextOptionsBuilder<SlideALamaDbContext>()
                .UseSqlServer("Server=(localdb)\\MSSQLLocalDB;Database=SlideALamaDb;Trusted_Connection=true")
                .Options;
            
            var context = new SlideALamaDbContext(options);
            // using var loggerFactory = LoggerFactory.Create(builder => builder.AddConsole());
            //  _logger = loggerFactory.CreateLogger<Menu>();
            // var commentLogger = loggerFactory.CreateLogger<CommentServiceEF>();
            // var ratingLogger = loggerFactory.CreateLogger<RatingServiceEF>();

            //_commentService = new CommentServiceEF(context, commentLogger);
            // _ratingService = new RatingServiceEF(context, ratingLogger);
            _menu = new Menu(this);
            ScoreService = new ScoreServiceEF(context, null);
        }

        public void Init()
        {

            _menu.UpdateMenu("~Slide_a_Lama~", new[] { "Play", "Scores", "rating", "comments", "Exit" });
        }

        private void WriteField()
        {

            SetColors(ConsoleColor.Black, ConsoleColor.Red);
            Console.Write("////--" + _field.CurrentPlayer.Team + " Player--////\n");

            SetColors(ConsoleColor.White, ConsoleColor.Black);
            for (int row = 0; row < _field.RowCount; row++)
            {
                for (int column = 0; column < _field.ColumnCount; column++)
                {
                    Console.BackgroundColor = FindCubeColor(_field.GetCube(row, column).Value);
                    Console.Write(_field.GetCube(row, column).Value + " ");
                    Console.BackgroundColor = ConsoleColor.White;
                }

                Console.Write("\n");
            }
            Console.ForegroundColor = ConsoleColor.Black;//scores
            Console.WriteLine("");
            for (int player = 0; player < _field.PlayersCount; player++)
            {
                Console.WriteLine("Player" + _field.Players[player].Team + ": " + _field.Players[player].Score);
            }


        }

        private ConsoleColor FindCubeColor(int value)
        {
            switch (value)
            {
                case 1:
                    return ConsoleColor.DarkGray;
                case 2:
                    return ConsoleColor.DarkYellow;
                case 3:
                    return ConsoleColor.Yellow;
                case 4:
                    return ConsoleColor.DarkCyan;
                case 5:
                    return ConsoleColor.Cyan;
                case 6:
                    return ConsoleColor.DarkGreen;
                case 7:
                    return ConsoleColor.Green;
            }

            return ConsoleColor.White;
        }

        private void Control(Thread blinker)
        {
            switch (Console.ReadKey().Key)
            {
                case ConsoleKey.RightArrow:
                    // ИЗМЕНЕНИЕ 3: Использовать метод фасада
                    _field.MoveRight(_field.CurrentCube[0]);
                    // БЫЛО: _field.MoveRight(_field.CurrentCube[0]); - но теперь это метод фасада
                    break;

                case ConsoleKey.LeftArrow:
                    // ИЗМЕНЕНИЕ 4: Использовать метод фасада  
                    _field.MoveLeft(_field.CurrentCube[0]);
                    // БЫЛО: _field.MoveLeft(_field.CurrentCube[0]); - но теперь это метод фасада
                    break;

                case ConsoleKey.UpArrow:
                    _field.MoveUp(_field.CurrentCube[1]);
                    break;

                case ConsoleKey.DownArrow:
                    _field.MoveDown(_field.CurrentCube[1]);
                    break;

                case ConsoleKey.Enter:
                    _field.PutCube();
                    break;

                case ConsoleKey.R:
                    Console.ResetColor();
                    blinker.Interrupt();
                    this.Init();
                    break;
            }
        }

        private void WriteFin()
        {
            Console.Clear();

            ScoreService.AddScore(new Score { Player = Environment.UserName, Points = _field.GetScore() });

            string wText = "Player " + _field.CurrentPlayer.Team + " win!";
            string wText2 = "Score is " + _field.GetScore();
            _menu.CreateFrame("~Congratulate~");
            _menu.FindCenter(wText, 0);
            SetColors(ConsoleColor.White, ConsoleColor.Black);
            Console.Write(wText);
            _menu.FindCenter(wText2, 1);
            Console.Write(wText2);

            wText = "(Press any key to continue)";
            _menu.FindCenter(wText, 2);
            Console.ResetColor();
            Console.Write(wText);
            Console.ReadKey();

            this.Init();
        }

        public void Play()
        {
            // ИЗМЕНЕНИЕ 2: Использовать фабрику вместо конструктора
            _field = FieldAdapterFactory.CreateField(8, 8, _menu.PlayersNumber, _menu.WinScore);
            // БЫЛО: _field = new Field(8, 8, _menu.PlayersNumber, _menu.WinScore);
            
            Console.Clear();
            while (_field.GameState == GameState.PLAYING)
            {
                if (_field.CurrentCube[0] != 0 && (_field.CurrentCube[1] != _field.ColumnCount - 1 && _field.CurrentCube[1] != 0))
                {
                    SetColors(ConsoleColor.White, ConsoleColor.Black);
                    _field.AddCube();
                }
                _field.UpdateField();

                _field.UpdateField();

                WriteField();

                var blinker = new Thread(Blink);
                blinker.Start();

                while (_field.UpdateField())
                {
                    _field.UpdateField();
                }
                
                // ИЗМЕНЕНИЕ 3 и 4: Заменить прямые вызовы MoveXXX на методы фасада
                Control(blinker);

                blinker.Interrupt();

                _field.UpdateField();
                Console.ResetColor();
                Console.Clear();
                _field.UpdateField();
            }
            WriteFin();
        }

        public void SetColors(ConsoleColor background, ConsoleColor foreground)
        {
            Console.BackgroundColor = background;
            Console.ForegroundColor = foreground;
        }

        private void Blink()
        {
            try
            {
                while (true)
                {
                    SetColors(ConsoleColor.White, ConsoleColor.Black);
                    Console.SetCursorPosition(_field.CurrentCube[1] * 2, _field.CurrentCube[0] + 1);
                    Console.Write(_field.GetCube(_field.CurrentCube[0], _field.CurrentCube[1]).Value + " ");
                    SetColors(FindCubeColor(_field.GetCube(_field.CurrentCube[0], _field.CurrentCube[1]).Value), ConsoleColor.Black);
                    Thread.Sleep(200);
                    Console.SetCursorPosition(_field.CurrentCube[1] * 2, _field.CurrentCube[0] + 1);
                    Console.Write(_field.GetCube(_field.CurrentCube[0], _field.CurrentCube[1]).Value + " ");
                    Thread.Sleep(200);


                }
            }
            catch (ThreadInterruptedException)
            {
                Thread.Sleep(Timeout.Infinite);
            }
            finally
            {
                Thread.EndThreadAffinity();
            }

        }
    }
}




// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide-a-Lama\UI\Menu.cs ---

﻿
using System;
using Datas.Entity;
using Datas.Service.Comments;
using Datas.Service.Rates;
using Datas.Entity;
using Datas.Service;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;

namespace Slide_a_Lama.UI
{
    internal class Menu
    {
        public int CurrentMItem { get; private set; }
        public int WinScore { get; private set; }
        public int PlayersNumber { get; private set; }

        private readonly ICommentService _commentService;
        private readonly IRatingService _ratingService;


        private string[] _menuItems;
        private readonly ConsoleUi _consoleUi;

        public Menu(ConsoleUi consoleUi)
        {
            _consoleUi = consoleUi;
            _menuItems = new string[3];
            CurrentMItem = 0;
            WinScore = 0;

            
            var options = new DbContextOptionsBuilder<SlideALamaDbContext>()
                .UseSqlServer("Server=(localdb)\\MSSQLLocalDB;Database=SlideALamaDb;Trusted_Connection=true")
                .Options;
            
            var context = new SlideALamaDbContext(options);
            
            // Простой консольный логгер
            //using var loggerFactory = LoggerFactory.Create(builder => builder.AddConsole());
            // _logger = loggerFactory.CreateLogger<Menu>();
            // var commentLogger = loggerFactory.CreateLogger<CommentServiceEF>();
            // var ratingLogger = loggerFactory.CreateLogger<RatingServiceEF>();

            _commentService = new CommentServiceEF(context, null);
            _ratingService = new RatingServiceEF(context, null);
        }


        public void FindCenter(String str, int offset)
        {
            int centerX = (Console.WindowWidth / 2) - (str.Length / 2);
            int centerY = (Console.WindowHeight / 2) - 1 + offset;
            Console.SetCursorPosition(centerX, centerY);
        }

        public void WriteInCenter(string str, int offset)
        {
            FindCenter(str, offset);
            Console.Write(str);
        }

        private void WriteFrameSection(ref int left, int top, string sign, int start, int end)
        {
            for (; start < end; start++)
            {
                Console.SetCursorPosition(left, top);
                Console.Write(sign);
                left -= 1;
            }
        }

        public void CreateFrame(String section)
        {

            int b = (Console.WindowWidth / 2) + 24;
            int c = (Console.WindowWidth / 2) + 24;

            Console.ForegroundColor = ConsoleColor.Green;
            WriteFrameSection(ref b, (Console.WindowHeight / 2) + 4, "╝", 0, 1);
            WriteFrameSection(ref b, (Console.WindowHeight / 2) + 4, "═", 0, 47);

            b += 1;
            WriteFrameSection(ref b, (Console.WindowHeight / 2) + 4, "╚", 0, 1);

            for (int a = (Console.WindowHeight / 2) - 1 - 6; a < (Console.WindowHeight / 2) - 1 + 4; a++) // лево право
            {
                Console.SetCursorPosition((Console.WindowWidth / 2) - 23, a + 1);
                Console.WriteLine("║");
                Console.SetCursorPosition((Console.WindowWidth / 2) + 24, a + 1);
                Console.WriteLine("║");
            }

            WriteFrameSection(ref c, (Console.WindowHeight / 2) - 6, "╗", 0, 1);
            WriteFrameSection(ref c, (Console.WindowHeight / 2) - 6, "═", 0, 47);

            c += 1;
            WriteFrameSection(ref c, (Console.WindowHeight / 2) - 6, "╔", 0, 1);

            Console.SetCursorPosition((Console.WindowWidth / 2) - (section.Length / 2), (Console.WindowHeight / 2) - 6);
            Console.Write(section);

            _consoleUi.SetColors(ConsoleColor.Black, ConsoleColor.White);
        }

        public void UpdateMenu(String menuSection, String[] menuItems)
        {
            Console.Clear();
            _menuItems = menuItems;
            CreateFrame(menuSection);

            for (int item = 0; item < menuItems.Length; item++)
            {
                if (item == CurrentMItem)
                {
                    _consoleUi.SetColors(ConsoleColor.White, ConsoleColor.Black);

                    WriteInCenter(menuItems[item], item - menuItems.Length / 2);
                    
                    _consoleUi.SetColors(ConsoleColor.Black, ConsoleColor.White);
                }

                else
                {
                    WriteInCenter(menuItems[item], item - menuItems.Length / 2);
                }
            }

            SelectItem(menuSection);
        }

        private void SelectItem(String menuSection)
        {
            bool movable = true;
            while (movable)
            {
                switch (Console.ReadKey().Key)
                {
                    case ConsoleKey.UpArrow:
                        CurrentMItem--;
                        if (CurrentMItem < 0)
                        {
                            CurrentMItem = _menuItems.Length - 1;
                        }
                        UpdateMenu(menuSection, _menuItems);
                        break;
                    case ConsoleKey.DownArrow:
                        CurrentMItem++;
                        if (CurrentMItem >= _menuItems.Length)
                        {
                            CurrentMItem = 0;
                        }
                        UpdateMenu(menuSection, _menuItems);
                        break;
                    case ConsoleKey.Enter:
                        Console.Clear();
                        switch (CurrentMItem)
                        {
                            case 0:
                                movable = false;
                                SetOptions();
                                _consoleUi.Play();
                                break;
                            case 1:
                                WriteScores();
                                break;
                            case 2:
                                WriteRates();
                                break;
                            case 3:
                                WriteComments();
                                break;
                            case 4:
                                movable = false;
                                Environment.Exit(0);
                                break;
                        }
                        break;
                }
            }
        }

        private void DisplayOptionsInput(string text, bool choise, int offset)
        {
            WriteInCenter(text,offset);
            FindCenter("xyz", offset+1);
            string check = Console.ReadLine();
            if (Int32.TryParse(check, out int res))
            {
                if (choise)
                {
                    WinScore = res;
                }
                else
                {
                    PlayersNumber = res;
                }
            }
        }
        private void SetOptions()
        {
            CreateFrame("Options");
            while (WinScore <= 0)
            {
                DisplayOptionsInput("Set the number of points needed to win", true, -2);
            }

            while (PlayersNumber <= 0)
            {
                DisplayOptionsInput("Set the number of players", false, 1);
            }
        }

        private void WriteComments()
        {
            CreateFrame("Comments");
            WriteInCenter("New comment(N) / show comments(s)", 0);

            while (true)
            {
                string check = Console.ReadLine();
                switch (check)
                {
                    case "s":
                        Console.Clear();
                        CreateFrame("Comments");
                        int i = -3;
                        foreach (var comment in _commentService.GetComments())
                        {
                            WriteInCenter(comment.Name, i);
                            i++;
                            Console.SetCursorPosition((Console.WindowWidth / 2) - 22, (Console.WindowHeight / 2) - 1 + i);
                            Console.WriteLine(comment.Text);
                            i++;
                        }

                        break;
                    case "n":
                    case "N":
                        Console.Clear();
                        CreateFrame("Comments");

                        WriteInCenter("Enter your name:", -4);
                        string name = Console.ReadLine();
                        WriteInCenter("Enter your comment:\n", -2);
                        Console.SetCursorPosition((Console.WindowWidth / 2) - 22, (Console.WindowHeight / 2) + 3);
                        string comm = Console.ReadLine();
                        _commentService.AddComment(new Comment {Name = name, Text = comm});
                        break;
                    default:
                        continue;

                }
                break;
            }

            WriteInCenter("Press ENTER to return to the menu", 3);
            WriteInCenter("or R to reset the comments", 4);
            if (Console.ReadKey().Key == ConsoleKey.Enter)
            {
                UpdateMenu("~Slide_a_Lama~", new[] { "Play", "Scores", "rating", "comments", "Exit" });
            }
            else if (Console.ReadKey().Key == ConsoleKey.R)
            {
                _commentService.ResetComments();
            }

        }

        private void WriteRates()
        {
            CreateFrame("Rating");
            WriteInCenter("New rate(N) / show rates(s)", 0);

            while (true)
            {
                string check = Console.ReadLine();
                switch (check)
                {
                    case "s":
                        Console.Clear();
                        CreateFrame("Rating");
                        int i = -3;
                        foreach (var rate in _ratingService.GetRates())
                        {
                            WriteInCenter(rate.Name + ": " + rate.mark,i);
                            i++;
                        }

                        break;
                    case "n":
                    case "N":
                        Console.Clear();
                        CreateFrame("Rating");
                        WriteInCenter("Enter your name:\n", -4);
                        FindCenter("qwerty", -3);
                        string name = Console.ReadLine();

                        WriteInCenter("Enter your mark (0-100):\n", -2);
                        FindCenter("qwerty", -1);
                        string mark = Console.ReadLine();
                       if (Int32.TryParse(mark, out int res) && res is > 0 and < 100 )
                       {
                            _ratingService.AddRate(new Rating { Name = name, mark = res });
                        }
                        break;
                    default:
                        continue;

                }
                break;
            }

            WriteInCenter("Press ENTER to return to the menu", 3);
            WriteInCenter("or R to reset Rating", 4);

            if (Console.ReadKey().Key == ConsoleKey.Enter)
            {
                UpdateMenu("~Slide_a_Lama~", new[] { "Play", "Scores", "rating", "comments", "Exit" });
            }
            else if (Console.ReadKey().Key == ConsoleKey.R)
            {
                _ratingService.ResetRates();
            }

        }

        private void WriteScores()
        {
            CreateFrame("Scores");
            int i = -3;
            foreach (var score in _consoleUi.ScoreService.GetTopScores())
            {
                FindCenter(score.Player, i);
                Console.WriteLine("{0}. {1} {2}", i + 4, score.Player, score.Points);
                i++;
            }

            WriteInCenter("Press ENTER to return to the menu", i + 1);
            WriteInCenter("or R to reset the scores", i + 2);
            if (Console.ReadKey().Key == ConsoleKey.Enter)
            {
                UpdateMenu("~Slide_a_Lama~", new[] { "Play", "Scores", "rating", "comments", "Exit" });
            }
            else if (Console.ReadKey().Key == ConsoleKey.R)
            {
                _consoleUi.ScoreService.ResetScore();
            }
        }
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide-a-Lama\UI\Program.cs ---


using Slide_a_Lama.UI;

namespace Slide_a_Lama.UI
{
    internal class Program
    {
        private static void Main()
        {
            ConsoleUi consoleUi = new ConsoleUi();
            consoleUi.Init();

        }
    }
}




// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide_a_LamaTest\UnitTest1.cs ---


using System;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Datas.Entity;
using Datas.Service;
using Datas.Service.Scores;

namespace Slide_a_LamaTest
{
    [TestClass]
    public class ScoreServiceTest
    {
        [TestMethod]
        public void AddTest1()
        {
            var service = CreateService();

            service.AddScore(new Score { Player = "Jhon", Points = 400 });

            Assert.AreEqual(1, service.GetTopScores().Count);

            Assert.AreEqual("Jhon", service.GetTopScores()[0].Player);
            Assert.AreEqual(400, service.GetTopScores()[0].Points);
        }

        [TestMethod]
        public void AddTest3()
        {
            var service = CreateService();

            service.AddScore(new Score { Player = "Branden", Points = 100 });
            service.AddScore(new Score { Player = "Olivia", Points = 70 });
            service.AddScore(new Score { Player = "Charlie", Points = 400 });

            Assert.AreEqual(3, service.GetTopScores().Count);

            Assert.AreEqual("Charlie", service.GetTopScores()[0].Player);
            Assert.AreEqual(400, service.GetTopScores()[0].Points);

            Assert.AreEqual("Branden", service.GetTopScores()[1].Player);
            Assert.AreEqual(100, service.GetTopScores()[1].Points);

            Assert.AreEqual("Olivia", service.GetTopScores()[2].Player);
            Assert.AreEqual(70, service.GetTopScores()[2].Points);
        }

        [TestMethod]
        public void AddTest5()
        {
            var service = CreateService();

            service.ResetScore();

            service.AddScore(new Score { Player = "Jessica", Points = 10 });
            service.AddScore(new Score { Player = "William", Points = 50 });
            service.AddScore(new Score { Player = "Riley", Points = 30 });
            service.AddScore(new Score { Player = "Sophie", Points = 100 });
            service.AddScore(new Score { Player = "Eva", Points = 120 });

            Assert.AreEqual(5, service.GetTopScores().Count);

            Assert.AreEqual("Eva", service.GetTopScores()[0].Player);
            Assert.AreEqual(120, service.GetTopScores()[0].Points);

            Assert.AreEqual("Sophie", service.GetTopScores()[1].Player);
            Assert.AreEqual(100, service.GetTopScores()[1].Points);

            Assert.AreEqual("William", service.GetTopScores()[2].Player);
            Assert.AreEqual(50, service.GetTopScores()[2].Points);
        }

        [TestMethod]
        public void AddTestCount()
        {
            var service = CreateService();
            Random rnd = new Random();

            for (int i = 0; i < 20; i++)
            {
                service.AddScore(new Score { Player = "William", Points = rnd.Next(1,700) });
            }

            Assert.AreEqual(5, service.GetTopScores().Count);
        }

        [TestMethod]
        public void ResetTest()
        {
            var service = CreateService();

            service.AddScore(new Score { Player = "Ryen", Points = 100 });
            service.AddScore(new Score { Player = "Lucy", Points = 100 });

            service.ResetScore();
            Assert.AreEqual(0, service.GetTopScores().Count);
        }

        private IScoreService CreateService()
        {
            //return new ScoreServiceFile();
            var service = new ScoreServiceEF(null, null);
            service.ResetScore();
            return service;
        }
    }
}




// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide_a_LamaTest\Core\ActiveCubeManagerTests.cs ---


// 2. Исправленные тесты ActiveCubeManagerTests.cs
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Moq;
using System;
using Slide_a_Lama.Core;

namespace Slide_a_LamaTest.Core
{
    [TestClass]
    public class ActiveCubeManagerTests
    {
        private GameSettings _settings;
        private ActiveCubeManager _manager;
        private Mock<IGameBoard> _mockBoard;
        private Mock<IRandomGenerator> _mockRandom;
        private Mock<ICubeMovement> _mockMovement;

        [TestInitialize]
        public void Setup()
        {
            _settings = new GameSettings(5, 6, 2, 1000); // RowCount=6, ColumnCount=8
            _manager = new ActiveCubeManager(_settings);
            _mockBoard = new Mock<IGameBoard>();
            _mockRandom = new Mock<IRandomGenerator>();
            _mockMovement = new Mock<ICubeMovement>();
        }

        [TestMethod]
        public void Constructor_ValidSettings_CreatesManager()
        {
            // Act & Assert
            Assert.IsNotNull(_manager);
            Assert.IsFalse(_manager.HasActiveCube);
            Assert.AreEqual(Position.Invalid, _manager.CurrentPosition);
        }

        [TestMethod]
        public void Constructor_NullSettings_ThrowsArgumentNullException()
        {
            // Act & Assert
            Assert.ThrowsException<ArgumentNullException>(() => new ActiveCubeManager(null));
        }

        [TestMethod]
        public void AddNewCube_CreatesAndPositionsCube()
        {
            // Arrange
            var centerPosition = _settings.GetCenterPosition(); // (0, 3) для нашего поля
            var cube = new Cube(0);
            
            _mockBoard.Setup(b => b.GetCube(centerPosition)).Returns(cube);
            _mockRandom.Setup(r => r.Next(GameSettings.MinCubeValue, GameSettings.MaxCubeValue + 1)).Returns(4);

            // Act
            _manager.AddNewCube(_mockBoard.Object, _mockRandom.Object);

            // Assert
            Assert.IsTrue(_manager.HasActiveCube);
            Assert.AreEqual(centerPosition, _manager.CurrentPosition);
            Assert.AreEqual(4, cube.Value);
            
            _mockRandom.Verify(r => r.Next(GameSettings.MinCubeValue, GameSettings.MaxCubeValue + 1), Times.Once);
        }

        [TestMethod]
        public void AddNewCube_NullCube_CreatesNewCube()
        {
            // Arrange
            var centerPosition = _settings.GetCenterPosition();
            var newCube = new Cube(0);
            
            _mockBoard.SetupSequence(b => b.GetCube(centerPosition))
                     .Returns((Cube)null)  // Первый вызов - null
                     .Returns(newCube);    // Второй вызов после SetCube - новый кубик
            
            _mockRandom.Setup(r => r.Next(It.IsAny<int>(), It.IsAny<int>())).Returns(3);

            // Act
            _manager.AddNewCube(_mockBoard.Object, _mockRandom.Object);

            // Assert
            Assert.IsTrue(_manager.HasActiveCube);
            Assert.AreEqual(centerPosition, _manager.CurrentPosition);
            _mockBoard.Verify(b => b.SetCube(centerPosition, It.IsAny<Cube>()), Times.Once);
        }

        [TestMethod]
        public void MoveTo_ValidMove_MovesSuccessfully()
        {
            // Arrange
            var startPosition = new Position(1, 1);
            var targetPosition = new Position(2, 2);
            var sourceCube = new Cube(5);
            var targetCube = new Cube(0);

            // Настраиваем начальную позицию
            _manager.SetPositionForTesting(startPosition);
            
            _mockBoard.Setup(b => b.CanMoveTo(targetPosition)).Returns(true);
            _mockBoard.Setup(b => b.GetCube(startPosition)).Returns(sourceCube);
            _mockBoard.Setup(b => b.GetCube(targetPosition)).Returns(targetCube);

            // Act
            var result = _manager.MoveTo(_mockBoard.Object, targetPosition);

            // Assert
            Assert.IsTrue(result);
            Assert.AreEqual(targetPosition, _manager.CurrentPosition);
            Assert.AreEqual(5, targetCube.Value);
            Assert.AreEqual(0, sourceCube.Value);
        }

        [TestMethod]
        public void MoveTo_InvalidMove_ReturnsFalse()
        {
            // Arrange
            var startPosition = new Position(1, 1);
            var targetPosition = new Position(2, 2);
            var sourceCube = new Cube(5);

            _manager.SetPositionForTesting(startPosition);
            _mockBoard.Setup(b => b.CanMoveTo(targetPosition)).Returns(false);
            _mockBoard.Setup(b => b.GetCube(startPosition)).Returns(sourceCube);

            // Act
            var result = _manager.MoveTo(_mockBoard.Object, targetPosition);

            // Assert
            Assert.IsFalse(result);
            Assert.AreEqual(startPosition, _manager.CurrentPosition); // Позиция не должна измениться
            Assert.AreEqual(5, sourceCube.Value); // Кубик не должен измениться
        }

        [TestMethod]
        public void MoveTo_NoActiveCube_ReturnsFalse()
        {
            // Arrange
            var targetPosition = new Position(2, 2);

            // Act (без активного кубика)
            var result = _manager.MoveTo(_mockBoard.Object, targetPosition);

            // Assert
            Assert.IsFalse(result);
        }

        [TestMethod]
        public void MoveTo_EmptySourceCube_ReturnsFalse()
        {
            // Arrange
            var startPosition = new Position(1, 1);
            var targetPosition = new Position(2, 2);
            var sourceCube = new Cube(0); // Пустой кубик

            _manager.SetPositionForTesting(startPosition);
            _mockBoard.Setup(b => b.CanMoveTo(targetPosition)).Returns(true);
            _mockBoard.Setup(b => b.GetCube(startPosition)).Returns(sourceCube);

            // Act
            var result = _manager.MoveTo(_mockBoard.Object, targetPosition);

            // Assert
            Assert.IsFalse(result);
        }

        [TestMethod]
        [DataRow(0, 3, true)]   // Верхняя граница (центр)
        [DataRow(2, 0, true)]   // Левая граница
        [DataRow(2, 7, true)]   // Правая граница (ColumnCount-1 = 8-1 = 7)
        [DataRow(1, 1, false)]  // Игровая область
        [DataRow(0, 0, false)]  // Угол
        [DataRow(0, 7, false)]  // Угол
        public void CanPutCube_VariousPositions_ReturnsExpected(int row, int col, bool expected)
        {
            // Arrange
            var position = new Position(row, col);
            
            _manager.SetPositionForTesting(position);
            
            // Настраиваем моки для проверки углов
            _mockBoard.Setup(b => b.IsCornerPosition(It.IsAny<Position>()))
                     .Returns<Position>(pos => 
                         (pos.Row == 0 && pos.Column == 0) ||
                         (pos.Row == 0 && pos.Column == _settings.ColumnCount - 1) ||
                         (pos.Row == _settings.RowCount - 1 && pos.Column == 0) ||
                         (pos.Row == _settings.RowCount - 1 && pos.Column == _settings.ColumnCount - 1));

            // Act
            var result = _manager.CanPutCube(_mockBoard.Object);

            // Assert
            Assert.AreEqual(expected, result, $"Position ({row}, {col}) should return {expected}");
        }

        [TestMethod]
        public void CanPutCube_NoActiveCube_ReturnsFalse()
        {
            // Act
            var result = _manager.CanPutCube(_mockBoard.Object);

            // Assert
            Assert.IsFalse(result);
        }

        [TestMethod]
        public void PutCube_ValidPosition_CallsMovement()
        {
            // Arrange
            var position = new Position(0, 3); // Верхняя граница
            
            _manager.SetPositionForTesting(position);
            _mockBoard.Setup(b => b.IsCornerPosition(position)).Returns(false);

            // Act
            _manager.PutCube(_mockBoard.Object, _mockMovement.Object);

            // Assert
            _mockMovement.Verify(m => m.MoveDown(_mockBoard.Object, position), Times.Once);
        }

        [TestMethod]
        public void PutCube_LeftBorder_CallsMoveRight()
        {
            // Arrange
            var position = new Position(2, 0); // Левая граница
            
            _manager.SetPositionForTesting(position);
            _mockBoard.Setup(b => b.IsCornerPosition(position)).Returns(false);

            // Act
            _manager.PutCube(_mockBoard.Object, _mockMovement.Object);

            // Assert
            _mockMovement.Verify(m => m.MoveRight(_mockBoard.Object, position), Times.Once);
        }

        [TestMethod]
        public void PutCube_RightBorder_CallsMoveLeft()
        {
            // Arrange
            var position = new Position(2, _settings.ColumnCount - 1); // Правая граница
            
            _manager.SetPositionForTesting(position);
            _mockBoard.Setup(b => b.IsCornerPosition(position)).Returns(false);

            // Act
            _manager.PutCube(_mockBoard.Object, _mockMovement.Object);

            // Assert
            _mockMovement.Verify(m => m.MoveLeft(_mockBoard.Object, position), Times.Once);
        }

        [TestMethod]
        public void PutCube_CornerPosition_DoesNothing()
        {
            // Arrange
            var position = new Position(0, 0); // Угол
            
            _manager.SetPositionForTesting(position);
            _mockBoard.Setup(b => b.IsCornerPosition(position)).Returns(true);

            // Act
            _manager.PutCube(_mockBoard.Object, _mockMovement.Object);

            // Assert
            _mockMovement.Verify(m => m.MoveDown(It.IsAny<IGameBoard>(), It.IsAny<Position>()), Times.Never);
            _mockMovement.Verify(m => m.MoveLeft(It.IsAny<IGameBoard>(), It.IsAny<Position>()), Times.Never);
            _mockMovement.Verify(m => m.MoveRight(It.IsAny<IGameBoard>(), It.IsAny<Position>()), Times.Never);
            _mockMovement.Verify(m => m.MoveUp(It.IsAny<IGameBoard>(), It.IsAny<Position>()), Times.Never);
        }

        [TestMethod]
        public void ResetPosition_ClearsCurrentPosition()
        {
            // Arrange
            var position = new Position(1, 1);
            _manager.SetPositionForTesting(position);

            // Act
            _manager.ResetPosition();

            // Assert
            Assert.IsFalse(_manager.HasActiveCube);
            Assert.AreEqual(Position.Invalid, _manager.CurrentPosition);
        }
    }
}





// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide_a_LamaTest\Core\AllCoreComponentsTestRunner.cs ---


// TestRunner.cs - Помощник для запуска всех тестов
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;
using System.Linq;
using System.Reflection;

namespace Slide_a_LamaTest.Core
{
    [TestClass]
    public class AllCoreComponentsTestRunner
    {
        [TestMethod]
        public void RunAllCoreTests_EnsureAllTestsPass()
        {
            // Этот тест служит как индикатор того, что все основные компоненты протестированы
            var testClasses = new[]
            {
                typeof(PositionTests),
                typeof(GameSettingsTests),
                typeof(GameBoardTests),
                typeof(ComboDetectorTests),
                typeof(CubePhysicsTests),
                typeof(PlayerManagerTests),
                typeof(ActiveCubeManagerTests),
                typeof(GameIntegrationTests),
                typeof(GameTestsWithMocks)
            };

            foreach (var testClass in testClasses)
            {
                var testMethods = testClass.GetMethods()
                    .Where(m => m.GetCustomAttribute<TestMethodAttribute>() != null)
                    .Count();
                
                Assert.IsTrue(testMethods > 0, $"{testClass.Name} should have test methods");
            }

            // Если этот тест проходит, значит структура тестов правильная
            Assert.IsTrue(true, "All core components have test coverage");
        }
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide_a_LamaTest\Core\ComboDetectorTests.cs ---


// ComboDetectorTests.cs
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Moq;
using System;
using System.Linq;
using Slide_a_Lama.Core;

namespace Slide_a_LamaTest.Core
{
    [TestClass]
    public class ComboDetectorTests
    {
        private GameSettings _settings;
        private ComboDetector _comboDetector;
        private Mock<IGameBoard> _mockBoard;

        [TestInitialize]
        public void Setup()
        {
            _settings = new GameSettings(5, 6, 2, 1000);
            _comboDetector = new ComboDetector(_settings);
            _mockBoard = new Mock<IGameBoard>();
            _mockBoard.Setup(b => b.Settings).Returns(_settings);
        }

        [TestMethod]
        public void Constructor_ValidSettings_CreatesDetector()
        {
            // Act & Assert
            Assert.IsNotNull(_comboDetector);
        }

        [TestMethod]
        public void Constructor_NullSettings_ThrowsArgumentNullException()
        {
            // Act & Assert
            Assert.ThrowsException<ArgumentNullException>(() => new ComboDetector(null));
        }

        [TestMethod]
        public void FindCombo_VerticalCombo_ReturnsComboResult()
        {
            // Arrange
            SetupVerticalCombo(1, 1, 3); // Вертикальная комбинация из троек в столбце 1, начиная со строки 1

            // Act
            var result = _comboDetector.FindCombo(_mockBoard.Object);

            // Assert
            Assert.IsTrue(result.Found);
            Assert.AreEqual(3, result.Value);
            Assert.AreEqual(ComboType.Vertical, result.Type);
            Assert.AreEqual(3, result.Positions.Count);
            
            var expectedPositions = new[]
            {
                new Position(1, 1),
                new Position(2, 1),
                new Position(3, 1)
            };
            
            CollectionAssert.AreEquivalent(expectedPositions, result.Positions.ToArray());
        }

        [TestMethod]
        public void FindCombo_HorizontalCombo_ReturnsComboResult()
        {
            // Arrange
            SetupHorizontalCombo(2, 1, 4); // Горизонтальная комбинация из четверок в строке 2, начиная со столбца 1

            // Act
            var result = _comboDetector.FindCombo(_mockBoard.Object);

            // Assert
            Assert.IsTrue(result.Found);
            Assert.AreEqual(4, result.Value);
            Assert.AreEqual(ComboType.Horizontal, result.Type);
            Assert.AreEqual(3, result.Positions.Count);
            
            var expectedPositions = new[]
            {
                new Position(2, 1),
                new Position(2, 2),
                new Position(2, 3)
            };
            
            CollectionAssert.AreEquivalent(expectedPositions, result.Positions.ToArray());
        }

        [TestMethod]
        public void FindCombo_NoCombo_ReturnsNotFound()
        {
            // Arrange
            SetupNoCombo();

            // Act
            var result = _comboDetector.FindCombo(_mockBoard.Object);

            // Assert
            Assert.IsFalse(result.Found);
            Assert.AreEqual(0, result.Value);
            Assert.AreEqual(0, result.Positions.Count);
        }

        [TestMethod]
        public void FindCombo_VerticalComboWithZeros_ReturnsNotFound()
        {
            // Arrange - комбинация из нулей не должна считаться
            SetupVerticalCombo(1, 1, 0);

            // Act
            var result = _comboDetector.FindCombo(_mockBoard.Object);

            // Assert
            Assert.IsFalse(result.Found);
        }

        [TestMethod]
        public void FindCombo_PartialCombo_ReturnsNotFound()
        {
            // Arrange - только 2 кубика одинаковых (недостаточно для комбо)
            var cubes = new[]
            {
                (new Position(1, 1), new Cube(5)),
                (new Position(2, 1), new Cube(5)),
                (new Position(3, 1), new Cube(2)) // Разный кубик
            };
            SetupMockBoardWithCubes(cubes);

            // Act
            var result = _comboDetector.FindCombo(_mockBoard.Object);

            // Assert
            Assert.IsFalse(result.Found);
        }

        [TestMethod]
        public void FindCombo_BothVerticalAndHorizontal_ReturnsVerticalFirst()
        {
            // Arrange - устанавливаем вертикальную комбинацию раньше по позиции
            var verticalCubes = new[]
            {
                (new Position(1, 1), new Cube(3)),
                (new Position(2, 1), new Cube(3)),
                (new Position(3, 1), new Cube(3))
            };
    
            var horizontalCubes = new[]
            {
                (new Position(2, 2), new Cube(5)),
                (new Position(2, 3), new Cube(5)),
                (new Position(2, 4), new Cube(5))
            };
    
            // Объединяем все кубики для мока
            var allCubes = verticalCubes.Concat(horizontalCubes).ToArray();
            SetupMockBoardWithCubes(allCubes);

            // Act
            var result = _comboDetector.FindCombo(_mockBoard.Object);

            // Assert
            Assert.IsTrue(result.Found);
            Assert.AreEqual(ComboType.Vertical, result.Type); // Вертикальные проверяются первыми
            Assert.AreEqual(3, result.Value);
        }


        [TestMethod]
        public void RemoveCombo_ValidCombo_RemovesCubes()
        {
            // Arrange
            var positions = new[]
            {
                new Position(1, 1),
                new Position(1, 2),
                new Position(1, 3)
            };
            
            var cubes = positions.Select(p => new Cube(3)).ToArray();
            
            _mockBoard.Setup(b => b.GetCube(positions[0])).Returns(cubes[0]);
            _mockBoard.Setup(b => b.GetCube(positions[1])).Returns(cubes[1]);
            _mockBoard.Setup(b => b.GetCube(positions[2])).Returns(cubes[2]);

            var combo = ComboResult.Create(3, ComboType.Horizontal, positions);

            // Act
            _comboDetector.RemoveCombo(_mockBoard.Object, combo);

            // Assert
            Assert.AreEqual(0, cubes[0].Value);
            Assert.AreEqual(0, cubes[1].Value);
            Assert.AreEqual(0, cubes[2].Value);
        }

        [TestMethod]
        public void RemoveCombo_NotFoundCombo_DoesNothing()
        {
            // Arrange
            var cube = new Cube(5);
            _mockBoard.Setup(b => b.GetCube(It.IsAny<Position>())).Returns(cube);
            var combo = ComboResult.NotFound;

            // Act
            _comboDetector.RemoveCombo(_mockBoard.Object, combo);

            // Assert
            Assert.AreEqual(5, cube.Value); // Кубик не должен измениться
        }

        [TestMethod]
        public void FindAndRemoveCombo_ValidCombo_FindsAndRemoves()
        {
            // Arrange
            SetupVerticalCombo(1, 1, 6);

            // Act
            var result = _comboDetector.FindAndRemoveCombo(_mockBoard.Object);

            // Assert
            Assert.IsTrue(result.Found);
            Assert.AreEqual(6, result.Value);
            
            // Проверяем что кубики были удалены (значение стало 0)
            _mockBoard.Verify(b => b.GetCube(new Position(1, 1)), Times.AtLeastOnce);
            _mockBoard.Verify(b => b.GetCube(new Position(2, 1)), Times.AtLeastOnce);
            _mockBoard.Verify(b => b.GetCube(new Position(3, 1)), Times.AtLeastOnce);
        }

        [TestMethod]
        public void HasPotentialCombos_WithCombo_ReturnsTrue()
        {
            // Arrange
            SetupVerticalCombo(1, 1, 2);

            // Act
            var hasCombos = _comboDetector.HasPotentialCombos(_mockBoard.Object);

            // Assert
            Assert.IsTrue(hasCombos);
        }

        [TestMethod]
        public void HasPotentialCombos_WithoutCombo_ReturnsFalse()
        {
            // Arrange
            SetupNoCombo();

            // Act
            var hasCombos = _comboDetector.HasPotentialCombos(_mockBoard.Object);

            // Assert
            Assert.IsFalse(hasCombos);
        }

        [TestMethod]
        public void FindCombo_EdgeVerticalCombo_ReturnsCombo()
        {
            // Arrange - комбинация в конце игрового поля
            var lastValidRow = _settings.RowCount - 3; // Последняя возможная позиция для вертикальной комбинации
            SetupVerticalCombo(lastValidRow, 1, 4);

            // Act
            var result = _comboDetector.FindCombo(_mockBoard.Object);

            // Assert
            Assert.IsTrue(result.Found);
            Assert.AreEqual(4, result.Value);
            Assert.AreEqual(ComboType.Vertical, result.Type);
        }

        [TestMethod]
        public void FindCombo_EdgeHorizontalCombo_ReturnsCombo()
        {
            // Arrange - комбинация в конце игрового поля
            var lastValidColumn = _settings.PlayableColumnEnd - 3; // Последняя возможная позиция для горизонтальной комбинации
            SetupHorizontalCombo(1, lastValidColumn, 5);

            // Act
            var result = _comboDetector.FindCombo(_mockBoard.Object);

            // Assert
            Assert.IsTrue(result.Found);
            Assert.AreEqual(5, result.Value);
            Assert.AreEqual(ComboType.Horizontal, result.Type);
        }

        #region Helper Methods

        private void SetupVerticalCombo(int startRow, int column, int value)
        {
            var cubes = new[]
            {
                (new Position(startRow, column), new Cube(value)),
                (new Position(startRow + 1, column), new Cube(value)),
                (new Position(startRow + 2, column), new Cube(value))
            };
            SetupMockBoardWithCubes(cubes);
        }

        private void SetupHorizontalCombo(int row, int startColumn, int value)
        {
            var cubes = new[]
            {
                (new Position(row, startColumn), new Cube(value)),
                (new Position(row, startColumn + 1), new Cube(value)),
                (new Position(row, startColumn + 2), new Cube(value))
            };
            SetupMockBoardWithCubes(cubes);
        }

        private void SetupNoCombo()
        {
            // Устанавливаем разные значения везде
            var cubes = new[]
            {
                (new Position(1, 1), new Cube(1)),
                (new Position(1, 2), new Cube(2)),
                (new Position(1, 3), new Cube(3)),
                (new Position(2, 1), new Cube(4)),
                (new Position(2, 2), new Cube(5)),
                (new Position(2, 3), new Cube(6)),
                (new Position(3, 1), new Cube(1)),
                (new Position(3, 2), new Cube(2)),
                (new Position(3, 3), new Cube(3))
            };
            SetupMockBoardWithCubes(cubes);
        }

        private void SetupMockBoardWithCubes((Position position, Cube cube)[] cubes)
        {
            // Сначала настроим все позиции как пустые
            _mockBoard.Setup(b => b.GetCube(It.IsAny<Position>()))
                .Returns(new Cube(0));
    
            // Затем настроим конкретные позиции с нужными кубиками
            foreach (var (position, cube) in cubes)
            {
                _mockBoard.Setup(b => b.GetCube(position)).Returns(cube);
            }
        }

        #endregion
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide_a_LamaTest\Core\CubePhysicsTests.cs ---


// CubePhysicsTests.cs
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Moq;
using System;
using System.Collections.Generic;
using Slide_a_Lama.Core;

namespace Slide_a_LamaTest.Core
{
    [TestClass]
    public class CubePhysicsTests
    {
        private GameSettings _settings;
        private CubePhysics _physics;
        private Mock<IGameBoard> _mockBoard;
        private Dictionary<Position, Cube> _boardState;

        [TestInitialize]
        public void Setup()
        {
            _settings = new GameSettings(5, 6, 2, 1000); // 5x6 игровое поле
            _physics = new CubePhysics(_settings);
            _mockBoard = new Mock<IGameBoard>();
            _boardState = new Dictionary<Position, Cube>();
            
            // Настраиваем мок доски для симуляции состояния
            _mockBoard.Setup(b => b.GetCube(It.IsAny<Position>()))
                     .Returns<Position>(pos => _boardState.ContainsKey(pos) ? _boardState[pos] : new Cube(0));
        }

        [TestMethod]
        public void Constructor_ValidSettings_CreatesPhysics()
        {
            // Act & Assert
            Assert.IsNotNull(_physics);
        }

        [TestMethod]
        public void Constructor_NullSettings_ThrowsArgumentNullException()
        {
            // Act & Assert
            Assert.ThrowsException<ArgumentNullException>(() => new CubePhysics(null));
        }

        [TestMethod]
        public void DropCubesInColumn_CubeAtTop_DropsToBottom()
        {
            // Arrange
            int column = 2;
            SetupColumnWithCubes(column, new[] { (1, 3), (2, 0), (3, 0), (4, 0), (5, 0) }); // Кубик 3 в верхней строке

            // Act
            var moved = _physics.DropCubesInColumn(_mockBoard.Object, column);

            // Assert
            Assert.IsTrue(moved);
            
            // Проверяем что кубик упал на дно
            var bottomCube = _boardState[new Position(_settings.RowCount - 1, column)];
            var topCube = _boardState[new Position(1, column)];
            
            Assert.AreEqual(3, bottomCube.Value, "Cube should have dropped to bottom");
            Assert.AreEqual(0, topCube.Value, "Original position should be empty");
        }

        [TestMethod]
        public void DropCubesInColumn_MultipleCubes_DropsInOrder()
        {
            // Arrange
            int column = 1;
            SetupColumnWithCubes(column, new[] { (1, 3), (2, 0), (3, 5), (4, 0), (5, 2) });

            // Act
            var moved = _physics.DropCubesInColumn(_mockBoard.Object, column);

            // Assert
            Assert.IsTrue(moved);
            
            // Кубики должны упасть в порядке: снизу 2, затем 5, затем 3
            Assert.AreEqual(2, _boardState[new Position(_settings.RowCount - 1, column)].Value);
            Assert.AreEqual(5, _boardState[new Position(_settings.RowCount - 2, column)].Value);
            Assert.AreEqual(3, _boardState[new Position(_settings.RowCount - 3, column)].Value);
            
            // Верхние позиции должны быть пустыми
            Assert.AreEqual(0, _boardState[new Position(1, column)].Value);
            Assert.AreEqual(0, _boardState[new Position(2, column)].Value);
        }

        [TestMethod]
        public void DropCubesInColumn_AlreadyAtBottom_NoMovement()
        {
            // Arrange
            int column = 1;
            SetupColumnWithCubes(column, new[] { (1, 0), (2, 0), (3, 0), (4, 0), (5, 3) }); // Кубик уже на дне

            // Act
            var moved = _physics.DropCubesInColumn(_mockBoard.Object, column);

            // Assert
            Assert.IsFalse(moved);
            
            // Кубик должен остаться на том же месте
            Assert.AreEqual(3, _boardState[new Position(_settings.RowCount - 1, column)].Value);
        }

        [TestMethod]
        public void DropCubesInColumn_EmptyColumn_NoMovement()
        {
            // Arrange
            int column = 1;
            SetupColumnWithCubes(column, new[] { (1, 0), (2, 0), (3, 0), (4, 0), (5, 0) }); // Пустой столбец

            // Act
            var moved = _physics.DropCubesInColumn(_mockBoard.Object, column);

            // Assert
            Assert.IsFalse(moved);
        }

        [TestMethod]
        public void DropCubesInColumn_FullColumn_NoMovement()
        {
            // Arrange
            int column = 1;
            SetupColumnWithCubes(column, new[] { (1, 1), (2, 2), (3, 3), (4, 4), (5, 5) }); // Полный столбец

            // Act
            var moved = _physics.DropCubesInColumn(_mockBoard.Object, column);

            // Assert
            Assert.IsFalse(moved);
            
            // Все кубики должны остаться на месте
            Assert.AreEqual(1, _boardState[new Position(1, column)].Value);
            Assert.AreEqual(2, _boardState[new Position(2, column)].Value);
            Assert.AreEqual(3, _boardState[new Position(3, column)].Value);
            Assert.AreEqual(4, _boardState[new Position(4, column)].Value);
            Assert.AreEqual(5, _boardState[new Position(5, column)].Value);
        }

        [TestMethod]
        public void DropAllCubes_MultipleColumns_DropsAllColumns()
        {
            // Arrange
            SetupMultipleColumnsWithCubes();

            // Act
            var moved = _physics.DropAllCubes(_mockBoard.Object);

            // Assert
            Assert.IsTrue(moved);
            
            // Проверяем что кубики упали во всех игровых столбцах
            for (int col = _settings.PlayableColumnStart; col < _settings.PlayableColumnEnd; col++)
            {
                // В каждом столбце должен быть кубик на дне
                var bottomCube = _boardState[new Position(_settings.RowCount - 1, col)];
                Assert.IsTrue(bottomCube.Value > 0, $"Column {col} should have cube at bottom");
            }
        }

        [TestMethod]
        public void DropAllCubes_NoMovement_ReturnsFalse()
        {
            // Arrange - создаем стабильное поле где ничего падать не должно
            for (int col = _settings.PlayableColumnStart; col < _settings.PlayableColumnEnd; col++)
            {
                SetupColumnWithCubes(col, new[] { (1, 0), (2, 0), (3, 0), (4, 0), (5, col) });
            }

            // Act
            var moved = _physics.DropAllCubes(_mockBoard.Object);

            // Assert
            Assert.IsFalse(moved);
        }

        [TestMethod]
        public void ForceDropAllCubes_ContinuesUntilStable()
        {
            // Arrange
            SetupColumnWithCubes(1, new[] { (1, 3), (2, 0), (3, 5), (4, 0), (5, 0) });
            
            int dropCallCount = 0;
            _physics = new TestableCubePhysics(_settings, () => 
            {
                dropCallCount++;
                // Симулируем что после первого вызова больше нечего падать
                return dropCallCount == 1;
            });

            // Act
            _physics.ForceDropAllCubes(_mockBoard.Object);

            // Assert
            Assert.AreEqual(2, dropCallCount, "Should call DropAllCubes until no more movement");
        }

        [TestMethod]
        public void ForceDropAllCubes_InfiniteLoop_ProtectionKicksIn()
        {
            // Arrange
            int dropCallCount = 0;
            _physics = new TestableCubePhysics(_settings, () => 
            {
                dropCallCount++;
                return true; // Всегда возвращаем true, симулируя бесконечное падение
            });

            // Act
            _physics.ForceDropAllCubes(_mockBoard.Object);

            // Assert
            Assert.AreEqual(20, dropCallCount, "Should stop at max iterations to prevent infinite loop");
        }

        [TestMethod]
        public void DropCubesInColumn_GapInMiddle_FillsGap()
        {
            // Arrange - кубик внизу, пробел, кубик вверху
            int column = 1;
            SetupColumnWithCubes(column, new[] { (1, 2), (2, 0), (3, 0), (4, 4), (5, 3) });

            // Act
            var moved = _physics.DropCubesInColumn(_mockBoard.Object, column);

            // Assert
            Assert.IsTrue(moved);
            
            // Кубики должны быть плотно упакованы снизу: 3, 4, 2
            Assert.AreEqual(3, _boardState[new Position(_settings.RowCount - 1, column)].Value);
            Assert.AreEqual(4, _boardState[new Position(_settings.RowCount - 2, column)].Value);
            Assert.AreEqual(2, _boardState[new Position(_settings.RowCount - 3, column)].Value);
            Assert.AreEqual(0, _boardState[new Position(1, column)].Value);
            Assert.AreEqual(0, _boardState[new Position(2, column)].Value);
        }

        #region Helper Methods

        private void SetupColumnWithCubes(int column, (int row, int value)[] cubes)
        {
            foreach (var (row, value) in cubes)
            {
                var position = new Position(row, column);
                _boardState[position] = new Cube(value);
            }
        }

        private void SetupMultipleColumnsWithCubes()
        {
            // Настраиваем несколько столбцов с кубиками которые должны упасть
            for (int col = _settings.PlayableColumnStart; col < _settings.PlayableColumnEnd; col++)
            {
                SetupColumnWithCubes(col, new[] { (1, col), (2, 0), (3, 0), (4, 0), (5, 0) });
            }
        }

        #endregion

        #region Test Helper Classes

        /// <summary>
        /// Тестовая версия CubePhysics которая позволяет мокать DropAllCubes
        /// </summary>
        private class TestableCubePhysics : CubePhysics
        {
            private readonly Func<bool> _dropAllCubesFunc;

            public TestableCubePhysics(GameSettings settings, Func<bool> dropAllCubesFunc) : base(settings)
            {
                _dropAllCubesFunc = dropAllCubesFunc;
            }

            public override bool DropAllCubes(IGameBoard board)
            {
                return _dropAllCubesFunc();
            }
        }

        #endregion
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide_a_LamaTest\Core\GameBoardTests.cs ---


// GameBoardTests.cs
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Moq;
using System;
using System.Linq;
using Slide_a_Lama.Core;

namespace Slide_a_LamaTest.Core
{
    [TestClass]
    public class GameBoardTests
    {
        private GameSettings _settings;
        private GameBoard _gameBoard;
        private Mock<IRandomGenerator> _mockRandom;

        [TestInitialize]
        public void Setup()
        {
            _settings = new GameSettings(5, 6, 2, 1000); // Создаем поле 5x6
            _gameBoard = new GameBoard(_settings);
            _mockRandom = new Mock<IRandomGenerator>();
        }

        [TestMethod]
        public void Constructor_ValidSettings_CreatesBoard()
        {
            // Act & Assert
            Assert.IsNotNull(_gameBoard);
            Assert.AreSame(_settings, _gameBoard.Settings);
        }

        [TestMethod]
        public void Constructor_NullSettings_ThrowsArgumentNullException()
        {
            // Act & Assert
            Assert.ThrowsException<ArgumentNullException>(() => new GameBoard(null));
        }

        [TestMethod]
        public void GetCube_ValidPosition_ReturnsCube()
        {
            // Arrange
            var position = new Position(1, 1);

            // Act
            var cube = _gameBoard.GetCube(position);

            // Assert
            Assert.IsNotNull(cube);
            Assert.AreEqual(0, cube.Value); // Новый кубик должен иметь значение 0
        }

        [TestMethod]
        public void GetCube_InvalidPosition_ReturnsNull()
        {
            // Arrange
            var position = new Position(-1, -1);

            // Act
            var cube = _gameBoard.GetCube(position);

            // Assert
            Assert.IsNull(cube);
        }

        [TestMethod]
        public void GetCube_SamePositionTwice_ReturnsSameCube()
        {
            // Arrange
            var position = new Position(2, 3);

            // Act
            var cube1 = _gameBoard.GetCube(position);
            var cube2 = _gameBoard.GetCube(position);

            // Assert
            Assert.AreSame(cube1, cube2);
        }

        [TestMethod]
        public void SetCube_ValidPosition_SetsCube()
        {
            // Arrange
            var position = new Position(1, 1);
            var newCube = new Cube(5);

            // Act
            _gameBoard.SetCube(position, newCube);
            var retrievedCube = _gameBoard.GetCube(position);

            // Assert
            Assert.AreSame(newCube, retrievedCube);
            Assert.AreEqual(5, retrievedCube.Value);
        }

        [TestMethod]
        public void SetCube_InvalidPosition_DoesNothing()
        {
            // Arrange
            var position = new Position(-1, -1);
            var newCube = new Cube(5);

            // Act & Assert (should not throw)
            _gameBoard.SetCube(position, newCube);
        }

        [TestMethod]
        public void IsEmptyCell_EmptyPosition_ReturnsTrue()
        {
            // Arrange
            var position = new Position(1, 1);

            // Act
            var isEmpty = _gameBoard.IsEmptyCell(position);

            // Assert
            Assert.IsTrue(isEmpty);
        }

        [TestMethod]
        public void IsEmptyCell_OccupiedPosition_ReturnsFalse()
        {
            // Arrange
            var position = new Position(1, 1);
            _gameBoard.GetCube(position).Value = 3;

            // Act
            var isEmpty = _gameBoard.IsEmptyCell(position);

            // Assert
            Assert.IsFalse(isEmpty);
        }

        [TestMethod]
        public void IsEmptyCell_InvalidPosition_ReturnsFalse()
        {
            // Arrange
            var position = new Position(-1, -1);

            // Act
            var isEmpty = _gameBoard.IsEmptyCell(position);

            // Assert
            Assert.IsFalse(isEmpty);
        }

        [TestMethod]
        [DataRow(1, 1, true)]   // Игровая область
        [DataRow(3, 4, true)]   // Игровая область
        [DataRow(0, 3, true)]   // Верхняя граница (не угол)
        [DataRow(2, 0, true)]   // Левая граница (не угол)
        [DataRow(2, 7, true)]   // Правая граница (не угол)
        [DataRow(0, 0, false)]  // Угол
        [DataRow(0, 7, false)]  // Угол
        [DataRow(-1, 1, false)] // Вне поля
        [DataRow(1, -1, false)] // Вне поля
        public void CanMoveTo_VariousPositions_ReturnsExpected(int row, int col, bool expected)
        {
            // Arrange
            var position = new Position(row, col);

            // Act
            var canMove = _gameBoard.CanMoveTo(position);

            // Assert
            Assert.AreEqual(expected, canMove);
        }

        [TestMethod]
        public void CanMoveTo_OccupiedPosition_ReturnsFalse()
        {
            // Arrange
            var position = new Position(1, 1);
            _gameBoard.GetCube(position).Value = 3; // Занимаем позицию

            // Act
            var canMove = _gameBoard.CanMoveTo(position);

            // Assert
            Assert.IsFalse(canMove);
        }

        [TestMethod]
        public void GetValidMoves_EmptyBoard_ReturnsValidPositions()
        {
            // Act
            var validMoves = _gameBoard.GetValidMoves();

            // Assert
            Assert.IsTrue(validMoves.Count > 0);
            
            // Проверяем что все возвращенные позиции действительно валидны
            foreach (var move in validMoves)
            {
                Assert.IsTrue(_gameBoard.CanMoveTo(move), $"Position {move} should be valid");
            }
        }

        [TestMethod]
        public void GetValidMoves_DoesNotIncludeCorners()
        {
            // Act
            var validMoves = _gameBoard.GetValidMoves();

            // Assert
            var corners = new[]
            {
                new Position(0, 0),
                new Position(0, _settings.ColumnCount - 1),
                new Position(_settings.RowCount - 1, 0),
                new Position(_settings.RowCount - 1, _settings.ColumnCount - 1)
            };

            foreach (var corner in corners)
            {
                Assert.IsFalse(validMoves.Contains(corner), $"Corner {corner} should not be in valid moves");
            }
        }

        [TestMethod]
        public void Initialize_CreatesProperBorders()
        {
            // Arrange
            _mockRandom.Setup(r => r.Next(It.IsAny<int>(), It.IsAny<int>())).Returns(3);

            // Act
            _gameBoard.Initialize(_mockRandom.Object);

            // Assert - проверяем границы
            // Левая и правая границы должны быть 0
            for (int row = 0; row < _settings.RowCount; row++)
            {
                Assert.AreEqual(0, _gameBoard.GetCube(new Position(row, 0)).Value, "Left border should be 0");
                Assert.AreEqual(0, _gameBoard.GetCube(new Position(row, _settings.ColumnCount - 1)).Value, "Right border should be 0");
            }

            // Верхняя граница должна быть 0
            for (int col = 0; col < _settings.ColumnCount; col++)
            {
                Assert.AreEqual(0, _gameBoard.GetCube(new Position(0, col)).Value, "Top border should be 0");
            }
        }

        [TestMethod]
        public void Initialize_FillsPlayableAreaWithRandomValues()
        {
            // Arrange
            _mockRandom.Setup(r => r.Next(It.IsAny<int>(), It.IsAny<int>())).Returns(4);

            // Act
            _gameBoard.Initialize(_mockRandom.Object);

            // Assert - проверяем что игровая область заполнена
            for (int row = _settings.PlayableRowStart; row < _settings.PlayableRowEnd; row++)
            {
                for (int col = _settings.PlayableColumnStart; col < _settings.PlayableColumnEnd; col++)
                {
                    var cube = _gameBoard.GetCube(new Position(row, col));
                    Assert.AreEqual(4, cube.Value, $"Playable area at ({row}, {col}) should have value 4");
                }
            }

            // Проверяем что генератор был вызван правильное количество раз
            int expectedCalls = _settings.OriginalRowCount * _settings.OriginalColumnCount;
            _mockRandom.Verify(r => r.Next(GameSettings.MinCubeValue, GameSettings.MaxCubeValue + 1), 
                Times.Exactly(expectedCalls));
        }

        [TestMethod]
        public void FillEmptyCells_FillsOnlyEmptyPositions()
        {
            // Arrange
            _gameBoard.Initialize(_mockRandom.Object);
            
            // Делаем некоторые ячейки пустыми
            _gameBoard.GetCube(new Position(1, 1)).Value = 0;
            _gameBoard.GetCube(new Position(2, 2)).Value = 0;
            _gameBoard.GetCube(new Position(3, 3)).Value = 5; // Эта остается непустой

            _mockRandom.Setup(r => r.Next(It.IsAny<int>(), It.IsAny<int>())).Returns(6);

            // Act
            _gameBoard.FillEmptyCells(_mockRandom.Object);

            // Assert
            Assert.AreEqual(6, _gameBoard.GetCube(new Position(1, 1)).Value);
            Assert.AreEqual(6, _gameBoard.GetCube(new Position(2, 2)).Value);
            Assert.AreEqual(5, _gameBoard.GetCube(new Position(3, 3)).Value); // Должна остаться неизменной
        }

        [TestMethod]
        public void ValidateIntegrity_ValidField_ReturnsTrue()
        {
            // Arrange
            _mockRandom.Setup(r => r.Next(It.IsAny<int>(), It.IsAny<int>())).Returns(1);
            _gameBoard.Initialize(_mockRandom.Object);

            // Act
            var isValid = _gameBoard.ValidateIntegrity();

            // Assert
            Assert.IsTrue(isValid);
        }

        [TestMethod]
        public void ValidateIntegrity_FloatingCube_ReturnsFalse()
        {
            // Arrange
            _mockRandom.Setup(r => r.Next(It.IsAny<int>(), It.IsAny<int>())).Returns(1);
            _gameBoard.Initialize(_mockRandom.Object);

            // Создаем "висящий" кубик - пустое место с кубиком над ним
            int testColumn = _settings.PlayableColumnStart;
            _gameBoard.GetCube(new Position(_settings.RowCount - 2, testColumn)).Value = 0; // Пустое место
            _gameBoard.GetCube(new Position(_settings.RowCount - 3, testColumn)).Value = 3; // Кубик над ним

            // Act
            var isValid = _gameBoard.ValidateIntegrity();

            // Assert
            Assert.IsFalse(isValid);
        }

        [TestMethod]
        public void ValidateIntegrity_EmptyColumn_ReturnsTrue()
        {
            // Arrange
            _mockRandom.Setup(r => r.Next(It.IsAny<int>(), It.IsAny<int>())).Returns(1);
            _gameBoard.Initialize(_mockRandom.Object);

            // Очищаем весь столбец
            int testColumn = _settings.PlayableColumnStart;
            for (int row = _settings.PlayableRowStart; row < _settings.PlayableRowEnd; row++)
            {
                _gameBoard.GetCube(new Position(row, testColumn)).Value = 0;
            }

            // Act
            var isValid = _gameBoard.ValidateIntegrity();

            // Assert
            Assert.IsTrue(isValid); // Пустой столбец должен быть валидным
        }
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide_a_LamaTest\Core\GameIntegrationTests.cs ---


// GameIntegrationTests.cs
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Moq;
using System;
using System.Linq;
using Slide_a_Lama;
using Slide_a_Lama.Core;

namespace Slide_a_LamaTest.Core
{
    [TestClass]
    public class GameIntegrationTests
    {
        private Game _game;
        private GameSettings _settings;

        [TestInitialize]
        public void Setup()
        {
            _settings = new GameSettings(5, 6, 2, 1000);
            _game = new Game(_settings);
        }

        [TestMethod]
        public void Constructor_ValidParameters_CreatesGame()
        {
            // Act & Assert
            Assert.IsNotNull(_game);
            Assert.AreEqual(GameState.PLAYING, _game.GameState);
            Assert.AreSame(_settings, _game.Settings);
            Assert.AreEqual(2, _game.Players.Count);
            Assert.IsNotNull(_game.CurrentPlayer);
            Assert.IsFalse(_game.ToMenu);
        }

        [TestMethod]
        public void Constructor_WithSimpleParameters_CreatesGame()
        {
            // Act
            var game = new Game(8, 10, 3, 2000);

            // Assert
            Assert.IsNotNull(game);
            Assert.AreEqual(8, game.Settings.OriginalRowCount);
            Assert.AreEqual(10, game.Settings.OriginalColumnCount);
            Assert.AreEqual(3, game.Players.Count);
            Assert.AreEqual(2000, game.Settings.WinScore);
        }

        [TestMethod]
        public void AddCube_FirstTime_CreatesActiveCube()
        {
            // Act
            _game.AddCube();

            // Assert
            Assert.IsTrue(_game.HasActiveCube());
            Assert.IsTrue(_game.GetCurrentCubeValue() > 0);
            Assert.AreEqual(_settings.GetCenterPosition(), _game.CurrentCubePosition);
        }

        [TestMethod]
        public void AddCube_SecondTime_SwitchesPlayer()
        {
            // Arrange
            _game.AddCube();
            var firstPlayer = _game.CurrentPlayer;

            // Act
            _game.AddCube();

            // Assert
            Assert.AreNotSame(firstPlayer, _game.CurrentPlayer);
            Assert.AreEqual(2, _game.CurrentPlayer.Team);
        }

        [TestMethod]
        public void AddCube_IncrementsTurns()
        {
            // Arrange
            var initialTurns = _game.CurrentPlayer.Turns;

            // Act
            _game.AddCube();

            // Assert
            Assert.AreEqual(initialTurns + 1, _game.CurrentPlayer.Turns);
        }

        [TestMethod]
        public void MoveCurCube_ValidPosition_MovesSuccessfully()
        {
            // Arrange
            _game.AddCube();
            var validMoves = _game.GetValidMoves();
            Assert.IsTrue(validMoves.Count > 0, "Should have valid moves available");
            var targetPosition = validMoves.First();

            // Act
            var result = _game.MoveCurCube(targetPosition);

            // Assert
            Assert.IsTrue(result);
            Assert.AreEqual(targetPosition, _game.CurrentCubePosition);
        }

        [TestMethod]
        public void MoveCurCube_InvalidPosition_ReturnsFalse()
        {
            // Arrange
            _game.AddCube();
            var invalidPosition = new Position(-1, -1);

            // Act
            var result = _game.MoveCurCube(invalidPosition);

            // Assert
            Assert.IsFalse(result);
            Assert.AreNotEqual(invalidPosition, _game.CurrentCubePosition);
        }

        [TestMethod]
        public void GetValidMoves_ReturnsPossibleMoves()
        {
            // Arrange
            _game.AddCube();

            // Act
            var validMoves = _game.GetValidMoves();

            // Assert
            Assert.IsTrue(validMoves.Count > 0);
            
            // Все возвращенные ходы должны быть действительно допустимыми
            foreach (var move in validMoves)
            {
                Assert.IsTrue(_game.CanMoveTo(move), $"Move {move} should be valid");
            }
        }

        
        [TestMethod]
        public void CanMoveTo_ValidMovesAreActuallyValid()
        {
            // Arrange
            var validMoves = _game.GetValidMoves();
    
            // Act & Assert - проверяем что все валидные ходы действительно валидны
            Assert.IsTrue(validMoves.Count > 0, "Game should have valid moves available");
    
            foreach (var move in validMoves.Take(5)) // Проверим первые 5 ходов
            {
                Assert.IsTrue(_game.CanMoveTo(move), $"Move {move} should be valid according to CanMoveTo");
            }
        }

        [TestMethod]
        public void CanMoveTo_CornerPosition_ReturnsFalse()
        {
            // Arrange
            var cornerPosition = new Position(0, 0);

            // Act
            var canMove = _game.CanMoveTo(cornerPosition);

            // Assert
            Assert.IsFalse(canMove);
        }

        [TestMethod]
        public void GetCube_ValidPosition_ReturnsCube()
        {
            // Arrange
            var position = new Position(1, 1);

            // Act
            var cube = _game.GetCube(position);

            // Assert
            Assert.IsNotNull(cube);
        }

        [TestMethod]
        public void GetCube_InvalidPosition_ReturnsNull()
        {
            // Arrange
            var position = new Position(-1, -1);

            // Act
            var cube = _game.GetCube(position);

            // Assert
            Assert.IsNull(cube);
        }

        [TestMethod]
        public void GetScore_InitialState_ReturnsZero()
        {
            // Act
            var score = _game.GetScore();

            // Assert
            Assert.AreEqual(0, score);
        }

        [TestMethod]
        public void UpdateField_NoChanges_ReturnsFalse()
        {
            // Act (на стабильном поле не должно быть изменений)
            var hasChanges = _game.UpdateField();

            // Assert
            Assert.IsFalse(hasChanges);
        }

        [TestMethod]
        public void ValidateFieldIntegrity_NewGame_ReturnsTrue()
        {
            // Act
            var isValid = _game.ValidateFieldIntegrity();

            // Assert
            Assert.IsTrue(isValid);
        }

        [TestMethod]
        public void CanPutCube_WithoutActiveCube_ReturnsFalse()
        {
            // Act (без добавления кубика)
            var canPut = _game.CanPutCube();

            // Assert
            Assert.IsFalse(canPut);
        }

        [TestMethod]
        public void CanPutCube_AtBorder_ReturnsTrue()
        {
            // Arrange
            _game.AddCube();
            var borderPosition = new Position(0, 3); // Верхняя граница
            _game.MoveCurCube(borderPosition);

            // Act
            var canPut = _game.CanPutCube();

            // Assert
            Assert.IsTrue(canPut);
        }

        [TestMethod]
        public void CanPutCube_AtCorner_ReturnsFalse()
        {
            // Arrange
            _game.AddCube();
            // Попытаемся переместить в угол (хотя это должно быть запрещено)
            var cornerPosition = new Position(0, 0);

            // Act
            var canMoveThere = _game.CanMoveTo(cornerPosition);
            
            // Assert
            Assert.IsFalse(canMoveThere); // Нельзя даже переместить в угол
        }

        [TestMethod]
        public void GameStateProgression_NormalGame_RemainsPlaying()
        {
            // Arrange & Act
            _game.AddCube();
            var validMove = _game.GetValidMoves().First();
            _game.MoveCurCube(validMove);
            _game.UpdateField();

            // Assert
            Assert.AreEqual(GameState.PLAYING, _game.GameState);
        }

        [TestMethod]
        public void PlayerSwitching_MultipleAdds_CyclesThroughPlayers()
        {
            // Arrange
            var player1 = _game.CurrentPlayer;

            // Act
            _game.AddCube(); // Первый кубик (игрок не переключается)
            Assert.AreSame(player1, _game.CurrentPlayer);

            _game.AddCube(); // Второй кубик (игрок переключается)
            var player2 = _game.CurrentPlayer;
            Assert.AreNotSame(player1, player2);

            _game.AddCube(); // Третий кубик (обратно к первому игроку)
            Assert.AreSame(player1, _game.CurrentPlayer);
        }

        [TestMethod]
        public void ForceDropAllCubes_RunsWithoutError()
        {
            // Act & Assert (должно выполниться без исключений)
            _game.ForceDropAllCubes();
        }

        [TestMethod]
        public void DebugPrintField_RunsWithoutError()
        {
            // Arrange
            _game.AddCube();

            // Act & Assert (должно выполниться без исключений)
            _game.DebugPrintField();
        }
    }
}







// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide_a_LamaTest\Core\GameSettingsTests.cs ---


// GameSettingsTests.cs
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;
using Slide_a_Lama.Core;

namespace Slide_a_LamaTest.Core
{
    [TestClass]
    public class GameSettingsTests
    {
        [TestMethod]
        public void Constructor_ValidParameters_CreatesSettings()
        {
            // Arrange & Act
            var settings = new GameSettings(8, 10, 2, 1000);
            
            // Assert
            Assert.AreEqual(8, settings.OriginalRowCount);
            Assert.AreEqual(10, settings.OriginalColumnCount);
            Assert.AreEqual(2, settings.PlayersCount);
            Assert.AreEqual(1000, settings.WinScore);
            
            // Проверяем расчетные параметры (с границами)
            Assert.AreEqual(9, settings.RowCount); // +1 для верхней границы
            Assert.AreEqual(12, settings.ColumnCount); // +2 для боковых границ
        }
        
        [TestMethod]
        public void Constructor_ValidParameters_CalculatesPlayableArea()
        {
            // Arrange & Act
            var settings = new GameSettings(5, 6, 1, 500);
            
            // Assert
            Assert.AreEqual(1, settings.PlayableRowStart);
            Assert.AreEqual(6, settings.PlayableRowEnd); // 5 + 1
            Assert.AreEqual(1, settings.PlayableColumnStart);
            Assert.AreEqual(7, settings.PlayableColumnEnd); // 6 + 2 - 1
        }
        
        [TestMethod]
        [DataRow(0, 8, 2, 1000)]
        [DataRow(8, 0, 2, 1000)]
        [DataRow(8, 8, 0, 1000)]
        [DataRow(8, 8, 2, 0)]
        [DataRow(-1, 8, 2, 1000)]
        public void Constructor_InvalidParameters_ThrowsArgumentException(int rows, int cols, int players, int winScore)
        {
            // Act & Assert
            Assert.ThrowsException<ArgumentException>(() => 
                new GameSettings(rows, cols, players, winScore));
        }
        
        [TestMethod]
        [DataRow(3, 3, true)]
        [DataRow(0, 0, true)]
        [DataRow(8, 11, true)]
        [DataRow(-1, 5, false)]
        [DataRow(5, -1, false)]
        [DataRow(9, 5, false)]
        [DataRow(5, 12, false)]
        public void IsValidPosition_VariousPositions_ReturnsExpected(int row, int col, bool expected)
        {
            // Arrange
            var settings = new GameSettings(8, 10, 2, 1000); // RowCount=9, ColumnCount=12
            var position = new Position(row, col);
            
            // Act
            var result = settings.IsValidPosition(position);
            
            // Assert
            Assert.AreEqual(expected, result);
        }
        
        [TestMethod]
        [DataRow(1, 1, true)]  // В игровой области
        [DataRow(2, 5, true)]  // В игровой области
        [DataRow(8, 10, true)] // В игровой области (граница)
        [DataRow(0, 5, false)] // Верхняя граница (не игровая)
        [DataRow(3, 0, false)] // Левая граница (не игровая)
        [DataRow(3, 11, false)] // Правая граница (не игровая)
        public void IsPlayablePosition_VariousPositions_ReturnsExpected(int row, int col, bool expected)
        {
            // Arrange
            var settings = new GameSettings(8, 10, 2, 1000);
            var position = new Position(row, col);
            
            // Act
            var result = settings.IsPlayablePosition(position);
            
            // Assert
            Assert.AreEqual(expected, result);
        }
        
        [TestMethod]
        [DataRow(0, 0, true)]   // Левый верхний угол
        [DataRow(0, 11, true)]  // Правый верхний угол
        [DataRow(8, 0, true)]   // Левый нижний угол
        [DataRow(8, 11, true)]  // Правый нижний угол
        [DataRow(0, 5, false)]  // Верхняя граница (не угол)
        [DataRow(4, 0, false)]  // Левая граница (не угол)
        [DataRow(1, 1, false)]  // Игровая область
        public void IsCornerPosition_VariousPositions_ReturnsExpected(int row, int col, bool expected)
        {
            // Arrange
            var settings = new GameSettings(8, 10, 2, 1000); // RowCount=9, ColumnCount=12
            var position = new Position(row, col);
            
            // Act
            var result = settings.IsCornerPosition(position);
            
            // Assert
            Assert.AreEqual(expected, result);
        }
        
        [TestMethod]
        [DataRow(0, 5, true)]   // Верхняя граница
        [DataRow(3, 0, true)]   // Левая граница (не угол)
        [DataRow(3, 11, true)]  // Правая граница (не угол)
        [DataRow(0, 0, false)]  // Угол (не граница в нашем понимании)
        [DataRow(1, 1, false)]  // Игровая область
        public void IsBorderPosition_VariousPositions_ReturnsExpected(int row, int col, bool expected)
        {
            // Arrange
            var settings = new GameSettings(8, 10, 2, 1000);
            var position = new Position(row, col);
            
            // Act
            var result = settings.IsBorderPosition(position);
            
            // Assert
            Assert.AreEqual(expected, result);
        }
        
        [TestMethod]
        public void GetCenterPosition_ReturnsCorrectCenter()
        {
            // Arrange
            var settings = new GameSettings(8, 10, 2, 1000); // ColumnCount = 12
            
            // Act
            var center = settings.GetCenterPosition();
            
            // Assert
            Assert.AreEqual(0, center.Row);
            Assert.AreEqual(5, center.Column); // (12-1)/2 = 5
        }
        
        [TestMethod]
        public void Constants_HaveExpectedValues()
        {
            // Assert
            Assert.AreEqual(50, GameSettings.MaxIterations);
            Assert.AreEqual(6, GameSettings.MaxCubeValue);
            Assert.AreEqual(1, GameSettings.MinCubeValue);
            Assert.AreEqual(5, GameSettings.TurnPenalty);
            Assert.AreEqual(10, GameSettings.ComboMultiplier);
        }
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide_a_LamaTest\Core\GameTestsWithMocks.cs ---


// GameTestsWithMocks.cs - Тесты с моками для более точного контроля

using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Moq;
using Slide_a_Lama;
using Slide_a_Lama.Core;
using Slide_a_LamaTest.Core.Helpers;

namespace Slide_a_LamaTest.Core
{
    [TestClass]
    public class GameTestsWithMocks
    {
        private GameSettings _settings;
        private Mock<IGameBoard> _mockBoard;
        private Mock<IComboDetector> _mockComboDetector;
        private Mock<ICubePhysics> _mockPhysics;
        private Mock<IPlayerManager> _mockPlayerManager;
        private Mock<IActiveCubeManager> _mockActiveCubeManager;
        private Mock<ICubeMovement> _mockCubeMovement;
        private MockRandomGenerator _mockRandom;
        private Game _game;

        [TestInitialize]
        public void Setup()
        {
            _settings = new GameSettings(5, 6, 2, 1000);
            _mockBoard = new Mock<IGameBoard>();
            _mockComboDetector = new Mock<IComboDetector>();
            _mockPhysics = new Mock<ICubePhysics>();
            _mockPlayerManager = new Mock<IPlayerManager>();
            _mockActiveCubeManager = new Mock<IActiveCubeManager>();
            _mockCubeMovement = new Mock<ICubeMovement>();
            _mockRandom = new MockRandomGenerator(3);

            // Настраиваем базовое поведение моков
            _mockPlayerManager.Setup(p => p.CurrentPlayer).Returns(new Player(1));
            _mockActiveCubeManager.Setup(a => a.CurrentPosition).Returns(new Position(0, 3));

            _game = new Game(
                _settings,
                _mockBoard.Object,
                _mockComboDetector.Object,
                _mockPhysics.Object,
                _mockPlayerManager.Object,
                _mockActiveCubeManager.Object,
                _mockCubeMovement.Object,
                _mockRandom);
        }

        [TestMethod]
        public void AddCube_CallsActiveCubeManagerAddNewCube()
        {
            // Act
            _game.AddCube();

            // Assert
            _mockActiveCubeManager.Verify(a => a.AddNewCube(_mockBoard.Object, _mockRandom), Times.Once);
            _mockPlayerManager.Verify(p => p.AddTurn(), Times.Once);
        }

        [TestMethod]
        public void MoveCurCube_CallsActiveCubeManagerMoveTo()
        {
            // Arrange
            var position = new Position(1, 1);
            _mockActiveCubeManager.Setup(a => a.MoveTo(_mockBoard.Object, position)).Returns(true);

            // Act
            var result = _game.MoveCurCube(position);

            // Assert
            Assert.IsTrue(result);
            _mockActiveCubeManager.Verify(a => a.MoveTo(_mockBoard.Object, position), Times.Once);
        }

        [TestMethod]
        public void PutCube_CallsActiveCubeManagerPutCube()
        {
            // Act
            _game.PutCube();

            // Assert
            _mockActiveCubeManager.Verify(a => a.PutCube(_mockBoard.Object, _mockCubeMovement.Object), Times.Once);
        }

        [TestMethod]
        public void UpdateField_CallsPhysicsAndComboDetector()
        {
            // Arrange
            _mockPhysics.Setup(p => p.DropAllCubes(_mockBoard.Object)).Returns(false);
            _mockComboDetector.Setup(c => c.FindAndRemoveCombo(_mockBoard.Object))
                             .Returns(ComboResult.NotFound);

            // Act
            var result = _game.UpdateField();

            // Assert
            Assert.IsFalse(result);
            _mockPhysics.Verify(p => p.DropAllCubes(_mockBoard.Object), Times.Once);
            _mockComboDetector.Verify(c => c.FindAndRemoveCombo(_mockBoard.Object), Times.Once);
        }

        [TestMethod]
        public void UpdateField_WithCombo_ProcessesComboAndUpdatesScore()
        {
            // Arrange
            var combo = ComboResult.Create(5, ComboType.Horizontal, new Position(1, 1));
    
            // Настраиваем последовательность вызовов
            var setupSequence = _mockComboDetector.SetupSequence(c => c.FindAndRemoveCombo(_mockBoard.Object));
            setupSequence.Returns(combo);  // Первый вызов - найдено комбо
            setupSequence.Returns(ComboResult.NotFound);  // Второй вызов - больше нет комбо
    
            _mockPhysics.Setup(p => p.DropAllCubes(_mockBoard.Object)).Returns(false);
            _mockPlayerManager.Setup(p => p.CheckWinCondition(_settings.WinScore)).Returns(false);

            // Act
            var result = _game.UpdateField();

            // Assert
            Assert.IsTrue(result); // Должен вернуть true из-за найденного combo
            _mockPlayerManager.Verify(p => p.AddScore(50), Times.Once); // 5 * 10 = 50
            _mockPlayerManager.Verify(p => p.CheckWinCondition(_settings.WinScore), Times.Once);
        }


        [TestMethod]
        public void UpdateField_WinCondition_SetsGameStateToWin()
        {
            // Arrange
            var combo = ComboResult.Create(6, ComboType.Vertical, new Position(1, 1));
            _mockPhysics.Setup(p => p.DropAllCubes(_mockBoard.Object)).Returns(false);
            _mockComboDetector.Setup(c => c.FindAndRemoveCombo(_mockBoard.Object))
                             .Returns(combo);
            _mockPlayerManager.Setup(p => p.CheckWinCondition(_settings.WinScore)).Returns(true);

            // Act
            _game.UpdateField();

            // Assert
            Assert.AreEqual(GameState.WIN, _game.GameState);
        }

        [TestMethod]
        public void GetValidMoves_CallsBoardGetValidMoves()
        {
            // Arrange
            var expectedMoves = new[] { new Position(1, 1), new Position(2, 2) };
            _mockBoard.Setup(b => b.GetValidMoves()).Returns(expectedMoves.ToList());

            // Act
            var moves = _game.GetValidMoves();

            // Assert
            CollectionAssert.AreEqual(expectedMoves, moves.ToArray());
            _mockBoard.Verify(b => b.GetValidMoves(), Times.Once);
        }

        [TestMethod]
        public void HasActiveCube_CallsActiveCubeManagerAndBoard()
        {
            // Arrange
            var position = new Position(1, 1);
            var cube = new Cube(5);
            
            _mockActiveCubeManager.Setup(a => a.HasActiveCube).Returns(true);
            _mockActiveCubeManager.Setup(a => a.CurrentPosition).Returns(position);
            _mockBoard.Setup(b => b.GetCube(position)).Returns(cube);

            // Act
            var hasActive = _game.HasActiveCube();

            // Assert
            Assert.IsTrue(hasActive);
            _mockActiveCubeManager.Verify(a => a.HasActiveCube, Times.Once);
            _mockBoard.Verify(b => b.GetCube(position), Times.Once);
        }

        [TestMethod]
        public void ForceDropAllCubes_CallsPhysicsForceDropAllCubes()
        {
            // Act
            _game.ForceDropAllCubes();

            // Assert
            _mockPhysics.Verify(p => p.ForceDropAllCubes(_mockBoard.Object), Times.Once);
        }
    }
}




// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide_a_LamaTest\Core\PlayerManagerTests.cs ---


// PlayerManagerTests.cs
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;
using System.Linq;
using Slide_a_Lama.Core;

namespace Slide_a_LamaTest.Core
{
    [TestClass]
    public class PlayerManagerTests
    {
        private PlayerManager _playerManager;

        [TestInitialize]
        public void Setup()
        {
            _playerManager = new PlayerManager(3); // 3 игрока
        }

        [TestMethod]
        public void Constructor_ValidPlayersCount_CreatesPlayers()
        {
            // Act & Assert
            Assert.AreEqual(3, _playerManager.PlayersCount);
            Assert.AreEqual(3, _playerManager.Players.Count);
            
            // Проверяем что игроки созданы с правильными номерами команд
            for (int i = 0; i < 3; i++)
            {
                Assert.AreEqual(i + 1, _playerManager.Players[i].Team);
                Assert.AreEqual(0, _playerManager.Players[i].Score);
                Assert.AreEqual(0, _playerManager.Players[i].Turns);
            }
        }

        [TestMethod]
        public void Constructor_ValidPlayersCount_SetsCurrentPlayer()
        {
            // Act & Assert
            Assert.IsNotNull(_playerManager.CurrentPlayer);
            Assert.AreEqual(1, _playerManager.CurrentPlayer.Team); // Первый игрок
        }

        [TestMethod]
        [DataRow(0)]
        [DataRow(-1)]
        [DataRow(-10)]
        public void Constructor_InvalidPlayersCount_ThrowsArgumentException(int playersCount)
        {
            // Act & Assert
            Assert.ThrowsException<ArgumentException>(() => new PlayerManager(playersCount));
        }

        [TestMethod]
        public void SwitchToNextPlayer_ThreePlayers_CyclesThroughPlayers()
        {
            // Arrange
            Assert.AreEqual(1, _playerManager.CurrentPlayer.Team);

            // Act & Assert
            _playerManager.SwitchToNextPlayer();
            Assert.AreEqual(2, _playerManager.CurrentPlayer.Team);

            _playerManager.SwitchToNextPlayer();
            Assert.AreEqual(3, _playerManager.CurrentPlayer.Team);

            _playerManager.SwitchToNextPlayer();
            Assert.AreEqual(1, _playerManager.CurrentPlayer.Team); // Циклично возвращаемся к первому
        }

        [TestMethod]
        public void SwitchToNextPlayer_OnePlayer_StaysWithSamePlayer()
        {
            // Arrange
            var singlePlayerManager = new PlayerManager(1);

            // Act
            singlePlayerManager.SwitchToNextPlayer();

            // Assert
            Assert.AreEqual(1, singlePlayerManager.CurrentPlayer.Team);
        }

        [TestMethod]
        public void AddScore_ValidPoints_AddsToCurrentPlayer()
        {
            // Arrange
            var initialScore = _playerManager.CurrentPlayer.Score;

            // Act
            _playerManager.AddScore(150);

            // Assert
            Assert.AreEqual(initialScore + 150, _playerManager.CurrentPlayer.Score);
        }

        [TestMethod]
        public void AddScore_MultipleAdds_AccumulatesScore()
        {
            // Act
            _playerManager.AddScore(100);
            _playerManager.AddScore(50);
            _playerManager.AddScore(25);

            // Assert
            Assert.AreEqual(175, _playerManager.CurrentPlayer.Score);
        }

        [TestMethod]
        public void AddTurn_IncrementsCurrentPlayerTurns()
        {
            // Arrange
            var initialTurns = _playerManager.CurrentPlayer.Turns;

            // Act
            _playerManager.AddTurn();

            // Assert
            Assert.AreEqual(initialTurns + 1, _playerManager.CurrentPlayer.Turns);
        }

        [TestMethod]
        public void GetCurrentScore_WithoutPenalty_ReturnsRawScore()
        {
            // Arrange
            _playerManager.AddScore(100);

            // Act
            var score = _playerManager.GetCurrentScore();

            // Assert
            Assert.AreEqual(100, score);
        }

        [TestMethod]
        public void GetCurrentScore_WithPenalty_ReturnsAdjustedScore()
        {
            // Arrange
            _playerManager.AddScore(100);
            _playerManager.AddTurn(); // +5 penalty
            _playerManager.AddTurn(); // +5 penalty

            // Act
            var score = _playerManager.GetCurrentScore();

            // Assert
            Assert.AreEqual(90, score); // 100 - (2 * 5)
        }

        [TestMethod]
        public void GetCurrentScore_NegativeResult_ReturnsZero()
        {
            // Arrange
            _playerManager.AddScore(20);
            for (int i = 0; i < 10; i++) // 10 * 5 = 50 penalty
            {
                _playerManager.AddTurn();
            }

            // Act
            var score = _playerManager.GetCurrentScore();

            // Assert
            Assert.AreEqual(0, score); // Math.Max(0, 20 - 50) = 0
        }

        [TestMethod]
        [DataRow(1000, 1000, true)]
        [DataRow(1500, 1000, true)]
        [DataRow(999, 1000, false)]
        [DataRow(0, 1000, false)]
        public void CheckWinCondition_VariousScores_ReturnsExpected(int playerScore, int winScore, bool expected)
        {
            // Arrange
            _playerManager.AddScore(playerScore);

            // Act
            var hasWon = _playerManager.CheckWinCondition(winScore);

            // Assert
            Assert.AreEqual(expected, hasWon);
        }

        [TestMethod]
        public void ResetCurrentPlayerStats_ResetsScoreAndTurns()
        {
            // Arrange
            _playerManager.AddScore(500);
            _playerManager.AddTurn();
            _playerManager.AddTurn();

            // Act
            _playerManager.ResetCurrentPlayerStats();

            // Assert
            Assert.AreEqual(0, _playerManager.CurrentPlayer.Score);
            Assert.AreEqual(0, _playerManager.CurrentPlayer.Turns);
        }

        // [TestMethod]
        // public void Players_ReturnsReadOnlyList()
        // {
        //     // Act
        //     var players = _playerManager.Players;
        //
        //     // Assert
        //     Assert.IsTrue(players.IsReadOnly);
        //     Assert.AreEqual(3, players.Count);
        // }
    }
}





// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide_a_LamaTest\Core\PositionTests.cs ---


// PositionTests.cs
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Slide_a_Lama.Core;

namespace Slide_a_LamaTest.Core
{
    [TestClass]
    public class PositionTests
    {
        [TestMethod]
        public void Constructor_ValidCoordinates_CreatesPosition()
        {
            // Arrange & Act
            var position = new Position(5, 10);
            
            // Assert
            Assert.AreEqual(5, position.Row);
            Assert.AreEqual(10, position.Column);
        }
        
        [TestMethod]
        public void Constructor_NegativeCoordinates_CreatesPosition()
        {
            // Arrange & Act
            var position = new Position(-1, -1);
            
            // Assert
            Assert.AreEqual(-1, position.Row);
            Assert.AreEqual(-1, position.Column);
        }
        
        [TestMethod]
        public void Equals_SameCoordinates_ReturnsTrue()
        {
            // Arrange
            var position1 = new Position(3, 4);
            var position2 = new Position(3, 4);
            
            // Act & Assert
            Assert.AreEqual(position1, position2);
            Assert.IsTrue(position1 == position2);
            Assert.IsFalse(position1 != position2);
        }
        
        [TestMethod]
        public void Equals_DifferentCoordinates_ReturnsFalse()
        {
            // Arrange
            var position1 = new Position(3, 4);
            var position2 = new Position(3, 5);
            
            // Act & Assert
            Assert.AreNotEqual(position1, position2);
            Assert.IsFalse(position1 == position2);
            Assert.IsTrue(position1 != position2);
        }
        
        [TestMethod]
        public void GetHashCode_SameCoordinates_ReturnsSameHash()
        {
            // Arrange
            var position1 = new Position(7, 8);
            var position2 = new Position(7, 8);
            
            // Act & Assert
            Assert.AreEqual(position1.GetHashCode(), position2.GetHashCode());
        }
        
        [TestMethod]
        public void ToString_ValidPosition_ReturnsFormattedString()
        {
            // Arrange
            var position = new Position(2, 3);
            
            // Act
            var result = position.ToString();
            
            // Assert
            Assert.AreEqual("(2, 3)", result);
        }
        
        [TestMethod]
        public void Invalid_ReturnsInvalidPosition()
        {
            // Act
            var invalid = Position.Invalid;
            
            // Assert
            Assert.AreEqual(-1, invalid.Row);
            Assert.AreEqual(-1, invalid.Column);
            Assert.IsFalse(invalid.IsValid);
        }
        
        [TestMethod]
        public void IsValid_ValidCoordinates_ReturnsTrue()
        {
            // Arrange
            var position = new Position(0, 0);
            
            // Act & Assert
            Assert.IsTrue(position.IsValid);
        }
        
        [TestMethod]
        public void IsValid_NegativeCoordinates_ReturnsFalse()
        {
            // Arrange
            var position1 = new Position(-1, 0);
            var position2 = new Position(0, -1);
            var position3 = new Position(-1, -1);
            
            // Act & Assert
            Assert.IsFalse(position1.IsValid);
            Assert.IsFalse(position2.IsValid);
            Assert.IsFalse(position3.IsValid);
        }
    }
}





// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide_a_LamaTest\Core\Helpers\MockRandomGenerator.cs ---


// MockRandomGenerator.cs - Вспомогательный класс для тестирования
using Slide_a_Lama.Core;

namespace Slide_a_LamaTest.Core.Helpers
{
    /// <summary>
    /// Предсказуемый генератор случайных чисел для тестирования
    /// </summary>
    public class MockRandomGenerator : IRandomGenerator
    {
        private readonly int _fixedValue;
        private readonly int[] _sequence;
        private int _currentIndex;

        public MockRandomGenerator(int fixedValue)
        {
            _fixedValue = fixedValue;
        }

        public MockRandomGenerator(params int[] sequence)
        {
            _sequence = sequence;
            _currentIndex = 0;
        }

        public int Next(int minValue, int maxValue)
        {
            if (_sequence != null)
            {
                if (_currentIndex >= _sequence.Length)
                    _currentIndex = 0; // Циклично повторяем последовательность
                
                return _sequence[_currentIndex++];
            }

            return _fixedValue;
        }
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide_a_Lama_Web\appsettings.Development.json ---


{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  }
}




// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide_a_Lama_Web\Program.cs ---


using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace Slide_a_LamaWeb
{
    public class Program
    {
        public static void Main(string[] args)
        {
            CreateHostBuilder(args).Build().Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args) =>
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =>
                {
                    webBuilder.UseStartup<Startup>();
                });
    }
}




// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide_a_Lama_Web\SessionExtensionsTuke.cs ---

﻿
using System;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;

namespace Microsoft.AspNetCore.Http
{
    public static class SessionExtensionsTuke
    {
        public static object GetObject(this ISession session, string key)
        {
            BinaryFormatter bf = new BinaryFormatter();
            MemoryStream stream = new MemoryStream(session.Get(key));
            return bf.Deserialize(stream);
        }

        public static void SetObject(this ISession session, string key, object value)
        {
            BinaryFormatter bf = new BinaryFormatter();
            MemoryStream stream = new MemoryStream();
            bf.Serialize(stream, value);
            long len = stream.Length;
            byte[] serializedObject = new byte[len];
            Array.Copy(stream.GetBuffer(), serializedObject, len);
            session.Set(key, serializedObject);
        }
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide_a_Lama_Web\Startup.cs ---


using System;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Datas.Service;
using Datas.Service.Comments;
using Datas.Service.Rates;
using Datas.Service.Scores;
using Microsoft.EntityFrameworkCore;

namespace Slide_a_LamaWeb
{
    public class Startup
    {
        public Startup(IConfiguration configuration)
        {
            Configuration = configuration;
        }

        public IConfiguration Configuration { get; }

        // This method gets called by the runtime. Use this method to add services to the container.
        public void ConfigureServices(IServiceCollection services)
        {
            // Database context configuration
            services.AddDbContext<SlideALamaDbContext>(options =>
                options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));
        
            // Register all services with their interfaces
            services.AddScoped<IScoreService, ScoreServiceEF>();
            services.AddScoped<ICommentService, CommentServiceEF>();
            services.AddScoped<IRatingService, RatingServiceEF>();
            
            // Add controllers with views
            services.AddControllersWithViews();

            // Add session support
            services.AddDistributedMemoryCache();
            services.AddSession(options =>
            {
                options.IdleTimeout = TimeSpan.FromMinutes(30);
                options.Cookie.HttpOnly = true;
                options.Cookie.IsEssential = true;
            });
            
            // Add logging
            services.AddLogging();
        }

        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            else
            {
                app.UseExceptionHandler("/Home/Error");
                // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
                app.UseHsts();
            }
            
            app.UseHttpsRedirection();
            app.UseStaticFiles();
            app.UseRouting();
            app.UseSession();
            app.UseCookiePolicy();

            app.UseEndpoints(endpoints =>
            {
                endpoints.MapControllerRoute(
                    name: "default",
                    pattern: "{controller=Home}/{action=Index}/{id?}");
            });
        }
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide_a_Lama_Web\APIcontrollers\CommentController.cs ---

﻿
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using Datas.Entity;
using Datas.Service.Comments;

namespace Slide_a_Lama_Web.APIcontrollers
{
    [Route("api/[controller]")]
    [ApiController]
    public class CommentController : ControllerBase
    {
        private readonly ICommentService _commentService;
        private readonly ILogger<CommentController> _logger;

        // ✅ DI через конструктор
        public CommentController(ICommentService commentService, ILogger<CommentController> logger)
        {
            _commentService = commentService ?? throw new ArgumentNullException(nameof(commentService));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        // GET: /api/Comment
        [HttpGet]
        public async Task<ActionResult<IEnumerable<Comment>>> GetComments()
        {
            try
            {
                var comments = await _commentService.GetCommentsAsync();
                return Ok(comments);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving comments via API");
                return StatusCode(500, new { error = "Failed to retrieve comments" });
            }
        }

        // POST: /api/Comment
        [HttpPost]
        public async Task<ActionResult> PostComment([FromBody] Comment comment)
        {
            try
            {
                if (comment == null)
                {
                    return BadRequest(new { error = "Comment is required" });
                }

                if (!ModelState.IsValid)
                {
                    return BadRequest(ModelState);
                }

                await _commentService.AddCommentAsync(comment);
                return CreatedAtAction(nameof(GetComments), new { id = comment.Id }, comment);
            }
            catch (ArgumentException ex)
            {
                _logger.LogWarning(ex, "Invalid comment data: {Message}", ex.Message);
                return BadRequest(new { error = ex.Message });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error adding comment via API");
                return StatusCode(500, new { error = "Failed to add comment" });
            }
        }

        // DELETE: /api/Comment/reset
        [HttpDelete("reset")]
        public async Task<ActionResult> ResetComments()
        {
            try
            {
                await _commentService.ResetCommentsAsync();
                return NoContent();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error resetting comments via API");
                return StatusCode(500, new { error = "Failed to reset comments" });
            }
        }
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide_a_Lama_Web\APIcontrollers\RatingController.cs ---

﻿
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using Datas.Entity;
using Datas.Service.Rates;

namespace Slide_a_Lama_Web.APIcontrollers
{
    [Route("api/[controller]")]
    [ApiController]
    public class RatingController : ControllerBase
    {
        private readonly IRatingService _ratingService;
        private readonly ILogger<RatingController> _logger;

        public RatingController(IRatingService ratingService, ILogger<RatingController> logger)
        {
            _ratingService = ratingService ?? throw new ArgumentNullException(nameof(ratingService));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        // GET: /api/Rating
        [HttpGet]
        public async Task<ActionResult<IEnumerable<Rating>>> GetRatings()
        {
            try
            {
                var ratings = await _ratingService.GetRatesAsync();
                return Ok(ratings);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving ratings via API");
                return StatusCode(500, new { error = "Failed to retrieve ratings" });
            }
        }

        // POST: /api/Rating
        [HttpPost]
        public async Task<ActionResult> PostRating([FromBody] Rating rating)
        {
            try
            {
                if (rating == null)
                {
                    return BadRequest(new { error = "Rating is required" });
                }

                if (!ModelState.IsValid)
                {
                    return BadRequest(ModelState);
                }

                await _ratingService.AddRateAsync(rating);
                return CreatedAtAction(nameof(GetRatings), new { id = rating.id }, rating);
            }
            catch (ArgumentException ex)
            {
                _logger.LogWarning(ex, "Invalid rating data: {Message}", ex.Message);
                return BadRequest(new { error = ex.Message });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error adding rating via API");
                return StatusCode(500, new { error = "Failed to add rating" });
            }
        }

        // DELETE: /api/Rating/reset
        [HttpDelete("reset")]
        public async Task<ActionResult> ResetRatings()
        {
            try
            {
                await _ratingService.ResetRatesAsync();
                return NoContent();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error resetting ratings via API");
                return StatusCode(500, new { error = "Failed to reset ratings" });
            }
        }
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide_a_Lama_Web\APIcontrollers\ScoreController.cs ---

﻿
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using Datas.Entity;
using Datas.Service.Scores;

namespace Slide_a_LamaWeb.APIController
{
    [Route("api/[controller]")]
    [ApiController]
    public class ScoreController : ControllerBase
    {
        private readonly IScoreService _scoreService;
        private readonly ILogger<ScoreController> _logger;

        // ✅ DI через конструктор
        public ScoreController(IScoreService scoreService, ILogger<ScoreController> logger)
        {
            _scoreService = scoreService ?? throw new ArgumentNullException(nameof(scoreService));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        // GET: /api/Score
        [HttpGet]
        public async Task<ActionResult<IEnumerable<Score>>> GetScores()
        {
            try
            {
                var scores = await _scoreService.GetTopScoresAsync();
                return Ok(scores);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving scores via API");
                return StatusCode(500, new { error = "Failed to retrieve scores" });
            }
        }

        // GET: /api/Score/top/{count}
        [HttpGet("top/{count:int}")]
        public async Task<ActionResult<IEnumerable<Score>>> GetTopScores(int count)
        {
            try
            {
                if (count <= 0 || count > 100)
                {
                    return BadRequest(new { error = "Count must be between 1 and 100" });
                }

                var scores = await _scoreService.GetTopScoresAsync(count);
                return Ok(scores);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving top {Count} scores via API", count);
                return StatusCode(500, new { error = "Failed to retrieve scores" });
            }
        }

        // POST: /api/Score
        [HttpPost]
        public async Task<ActionResult> PostScore([FromBody] Score score)
        {
            try
            {
                if (score == null)
                {
                    return BadRequest(new { error = "Score is required" });
                }

                if (!ModelState.IsValid)
                {
                    return BadRequest(ModelState);
                }

                await _scoreService.AddScoreAsync(score);
                return CreatedAtAction(nameof(GetScores), new { id = score.id }, score);
            }
            catch (ArgumentException ex)
            {
                _logger.LogWarning(ex, "Invalid score data: {Message}", ex.Message);
                return BadRequest(new { error = ex.Message });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error adding score via API");
                return StatusCode(500, new { error = "Failed to add score" });
            }
        }

        // DELETE: /api/Score/reset
        [HttpDelete("reset")]
        public async Task<ActionResult> ResetScores()
        {
            try
            {
                await _scoreService.ResetScoreAsync();
                return NoContent();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error resetting scores via API");
                return StatusCode(500, new { error = "Failed to reset scores" });
            }
        }
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide_a_Lama_Web\Controllers\CommentsController.cs ---

﻿
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Datas.Entity;
using Datas.Service.Comments;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;


namespace Slide_a_LamaWeb.Controllers
{
    public class CommentsController : Controller
    {
        private readonly ICommentService _commentService;
        private readonly ILogger<CommentsController> _logger;

        public CommentsController(ICommentService commentService, ILogger<CommentsController> logger)
        {
            _commentService = commentService ?? throw new ArgumentNullException(nameof(commentService));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public async Task<IActionResult> Index()
        {
            try
            {
                var comments = await _commentService.GetCommentsAsync();
                ViewBag.CommentService = _commentService;
                return View("Index", comments);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error loading comments page");
                ViewBag.ErrorMessage = "Unable to load comments. Please try again later.";
                ViewBag.CommentService = _commentService;
                return View("Index", new List<Comment>());
            }
        }

        [HttpPost]
        public async Task<IActionResult> SaveComment(string Name, string Text)
        {
            try
            {
                if (string.IsNullOrWhiteSpace(Name) || string.IsNullOrWhiteSpace(Text))
                {
                    ModelState.AddModelError("", "Both name and comment text are required");
                    return await Index();
                }

                var comment = new Comment { Name = Name, Text = Text };
                await _commentService.AddCommentAsync(comment);
                
                return RedirectToAction("Index");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error adding comment for user {Name}", Name);
                ModelState.AddModelError("", "Failed to add comment. Please try again.");
                return await Index();
            }
        }

        [HttpPost]
        public async Task<IActionResult> ResetComments()
        {
            try
            {
                await _commentService.ResetCommentsAsync();
                return RedirectToAction("Index");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error resetting comments");
                ModelState.AddModelError("", "Failed to reset comments. Please try again.");
                return await Index();
            }
        }
    }
}




// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide_a_Lama_Web\Controllers\HomeController.cs ---

﻿
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;
using Slide_a_LamaWeb.Models;

namespace Slide_a_Lama_Web.Controllers
{
    public class HomeController : Controller
    {
        private readonly ILogger<HomeController> _logger;

        public HomeController(ILogger<HomeController> logger)
        {
            _logger = logger;
        }

        public IActionResult Index()
        {
            return View();
        }

        public IActionResult Privacy()
        {
            return View();
        }

        [ResponseCache(Duration = 0, Location = ResponseCacheLocation.None, NoStore = true)]
        public IActionResult Error()
        {
            return View(new ErrorViewModel { RequestId = Activity.Current?.Id ?? HttpContext.TraceIdentifier });
        }
    }
}




// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide_a_Lama_Web\Controllers\RatingController.cs ---

﻿
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using Datas.Entity;
using Datas.Service.Rates;

namespace Slide_a_LamaWeb.Controllers
{
    public class RatingController : Controller
    {
        private readonly IRatingService _ratingService;
        private readonly ILogger<RatingController> _logger;

        public RatingController(IRatingService ratingService, ILogger<RatingController> logger)
        {
            _ratingService = ratingService ?? throw new ArgumentNullException(nameof(ratingService));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public async Task<IActionResult> Index()
        {
            try
            {
                var ratings = await _ratingService.GetRatesAsync();
                ViewBag.RatingService = _ratingService;
                return View("Index", ratings);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error loading ratings page");
                ViewBag.ErrorMessage = "Unable to load ratings. Please try again later.";
                ViewBag.RatingService = _ratingService;
                return View("Index", new List<Rating>());
            }
        }

        [HttpPost]
        public async Task<IActionResult> SaveRate(string Name, int Mark)
        {
            try
            {
                if (string.IsNullOrWhiteSpace(Name))
                {
                    ModelState.AddModelError("", "Name is required");
                    return await Index();
                }

                if (Mark < 0 || Mark > 100)
                {
                    ModelState.AddModelError("", "Rating must be between 0 and 100");
                    return await Index();
                }

                var rating = new Rating { Name = Name, mark = Mark };
                await _ratingService.AddRateAsync(rating);
                
                return RedirectToAction("Index");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error adding rating for user {Name} with mark {Mark}", Name, Mark);
                ModelState.AddModelError("", "Failed to add rating. Please try again.");
                return await Index();
            }
        }

        [HttpPost]
        public async Task<IActionResult> ResetRates()
        {
            try
            {
                await _ratingService.ResetRatesAsync();
                return RedirectToAction("Index");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error resetting ratings");
                ModelState.AddModelError("", "Failed to reset ratings. Please try again.");
                return await Index();
            }
        }
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide_a_Lama_Web\Controllers\SaLController.cs ---

﻿
using Microsoft.AspNetCore.Mvc;
using System;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging;
using Slide_a_Lama;
using Slide_a_Lama.Core;
using Datas.Entity;
using Datas.Service.Scores;

namespace Slide_a_Lama_Web.Controllers
{
    public class SaLController : Controller
    {
        private const string FieldSessionKey = "field";
        
        private readonly IScoreService _scoreService;
        private readonly ILogger<SaLController> _logger;

        // ✅ DI через конструктор
        public SaLController(IScoreService scoreService, ILogger<SaLController> logger)
        {
            _scoreService = scoreService ?? throw new ArgumentNullException(nameof(scoreService));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }
        
        public IActionResult Index(int playerCount, int winScore)
        {
            try
            {
                _logger.LogInformation("Starting new game with {PlayerCount} players and win score {WinScore}", 
                    playerCount, winScore);
                
                FieldAdapter field = FieldAdapterFactory.CreateField(7, 8, playerCount, winScore);
                field.AddCube();
                
                HttpContext.Session.SetObject(FieldSessionKey, field);
                return View("Index", field);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error starting new game");
                return RedirectToAction("Index", "Home");
            }
        }

        public IActionResult Move(int row, int column)
        {
            try
            {
                var field = (FieldAdapter)HttpContext.Session.GetObject(FieldSessionKey);
                
                if (field == null)
                {
                    _logger.LogWarning("Game session not found, redirecting to home");
                    return RedirectToAction("Index", "Home");
                }

                // Проверяем, есть ли активный кубик для перемещения
                if (!field.HasActiveCube())
                {
                    // Если нет активного кубика, добавляем новый
                    field.AddCube();
                }

                // Проверяем, можно ли переместить кубик в указанную позицию
                if (field.CanMoveTo(row, column))
                {
                    field.MoveCurCube(row, column);
                    _logger.LogDebug("Moved cube to position ({Row}, {Column})", row, column);
                }

                HttpContext.Session.SetObject(FieldSessionKey, field);
                return View("Index", field);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error moving cube to position ({Row}, {Column})", row, column);
                return RedirectToAction("Index", "Home");
            }
        }

        public IActionResult Put()
        {
            try
            {
                var field = (FieldAdapter)HttpContext.Session.GetObject(FieldSessionKey);
                
                if (field == null)
                {
                    _logger.LogWarning("Game session not found, redirecting to home");
                    return RedirectToAction("Index", "Home");
                }

                // Размещаем кубик
                field.PutCube();
                
                // Принудительно роняем все кубики
                field.ForceDropAllCubes();
                
                // Обновляем поле до стабильного состояния
                int iterations = 0;
                while (field.UpdateField() && iterations < 20)
                {
                    // Продолжаем обновление пока есть изменения
                    // Ограничиваем количество итераций для предотвращения зависания
                    iterations++;
                }

                _logger.LogDebug("Field updated with {Iterations} iterations", iterations);

                // Добавляем новый кубик для следующего хода
                if (field.GameState == GameState.PLAYING)
                {
                    field.AddCube();
                }

                HttpContext.Session.SetObject(FieldSessionKey, field);
                return View("Index", field);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error putting cube");
                return RedirectToAction("Index", "Home");
            }
        }

        // ✅ Async метод для работы со ScoreService
        [HttpPost]
        public async Task<IActionResult> SaveScore(string Name)
        {
            try
            {
                var field = (FieldAdapter)HttpContext.Session.GetObject(FieldSessionKey);
                
                if (field != null && !string.IsNullOrWhiteSpace(Name))
                {
                    var score = new Score()
                    {
                        Player = Name.Trim(), 
                        Points = field.GetScore()
                    };

                    await _scoreService.AddScoreAsync(score);
                    _logger.LogInformation("Score saved for player {Player} with {Points} points", 
                        Name, score.Points);
                    
                    field.ToMenu = true;
                }
                else
                {
                    _logger.LogWarning("Invalid score save attempt - field: {FieldExists}, name: '{Name}'", 
                        field != null, Name);
                }

                return View("Index", field);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error saving score for player {Player}", Name);
                
                // Возвращаем поле в любом случае, чтобы пользователь мог попробовать еще раз
                var field = (FieldAdapter)HttpContext.Session.GetObject(FieldSessionKey);
                ViewBag.ErrorMessage = "Failed to save score. Please try again.";
                return View("Index", field);
            }
        }

        // Дополнительный метод для принудительного обновления поля
        [HttpPost]
        public JsonResult ForceUpdate()
        {
            try
            {
                var field = (FieldAdapter)HttpContext.Session.GetObject(FieldSessionKey);
                
                if (field == null)
                {
                    _logger.LogWarning("Force update called but game not found");
                    return Json(new { success = false, message = "Game not found" });
                }

                // Принудительно роняем все кубики
                field.ForceDropAllCubes();
                
                // Проверяем целостность поля
                bool isValid = field.ValidateFieldIntegrity();
                
                // Обновляем поле
                int updates = 0;
                while (field.UpdateField() && updates < 10)
                {
                    updates++;
                }

                HttpContext.Session.SetObject(FieldSessionKey, field);
                
                _logger.LogDebug("Force update completed - valid: {IsValid}, updates: {Updates}", 
                    isValid, updates);
                
                return Json(new 
                { 
                    success = true,
                    isValid = isValid,
                    updates = updates,
                    gameState = field.GameState.ToString()
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during force update");
                return Json(new { success = false, message = "Update failed" });
            }
        }

        // Дополнительный метод для получения состояния игры (AJAX)
        [HttpGet]
        public JsonResult GetGameState()
        {
            try
            {
                var field = (FieldAdapter)HttpContext.Session.GetObject(FieldSessionKey);
        
                if (field == null)
                {
                    _logger.LogWarning("Get game state called but game not found");
                    return Json(new { success = false, message = "Game not found" });
                }

                return Json(new 
                { 
                    success = true,
                    hasActiveCube = field.HasActiveCube(),
                    canPutCube = field.CanPutCube(),
                    currentCubeValue = field.GetCurrentCubeValue(),
                    currentCubePosition = new { row = field.CurrentCube[0], column = field.CurrentCube[1] },
                    validMoves = field.GetValidMoves(),
                    gameState = field.GameState.ToString(),
                    currentPlayer = field.CurrentPlayer.Team,
                    score = field.GetScore()
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting game state");
                return Json(new { success = false, message = "Failed to get game state" });
            }
        }

        // метод для получения топ результатов (async)
        [HttpGet]
        public async Task<JsonResult> GetTopScores(int count = 10)
        {
            try
            {
                var scores = await _scoreService.GetTopScoresAsync(count);
                return Json(new { success = true, scores = scores });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting top scores");
                return Json(new { success = false, message = "Failed to get scores" });
            }
        }

        // Метод для сброса результатов (async)
        [HttpPost]
        public async Task<JsonResult> ResetScores()
        {
            try
            {
                await _scoreService.ResetScoreAsync();
                _logger.LogWarning("Scores have been reset");
                return Json(new { success = true, message = "Scores reset successfully" });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error resetting scores");
                return Json(new { success = false, message = "Failed to reset scores" });
            }
        }
    }
}



// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide_a_Lama_Web\Controllers\ScoresController.cs ---

﻿
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Datas.Entity;
using Datas.Service.Scores;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using Datas.Service.Scores;

namespace Slide_a_LamaWeb.Controllers
{
    public class ScoresController : Controller
    {
        private readonly IScoreService _scoreService;
        private readonly ILogger<ScoresController> _logger;

        // ✅ DI через конструктор
        public ScoresController(IScoreService scoreService, ILogger<ScoresController> logger)
        {
            _scoreService = scoreService ?? throw new ArgumentNullException(nameof(scoreService));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        // ✅ Async действия
        public async Task<IActionResult> Index()
        {
            try
            {
                var scores = await _scoreService.GetTopScoresAsync();
                return View("Index", scores);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error loading scores page");
                ViewBag.ErrorMessage = "Unable to load scores. Please try again later.";
                return View("Index", new List<Score>());
            }
        }

        [HttpPost]
        public async Task<IActionResult> AddScore(string playerName, int points)
        {
            try
            {
                if (string.IsNullOrWhiteSpace(playerName))
                {
                    ModelState.AddModelError("", "Player name is required");
                    return await Index();
                }

                var score = new Score { Player = playerName, Points = points };
                await _scoreService.AddScoreAsync(score);
                
                return RedirectToAction("Index");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error adding score for player {Player}", playerName);
                ModelState.AddModelError("", "Failed to add score. Please try again.");
                return await Index();
            }
        }
    }
}




// --- End of File ---

// --- File: C:\Users\HP\Desktop\dotnet-5659-main\src\Slide-a-Lama\Slide_a_Lama_Web\Models\ErrorViewModel.cs ---


using System;

namespace Slide_a_LamaWeb.Models
{
    public class ErrorViewModel
    {
        public string RequestId { get; set; }

        public bool ShowRequestId => !string.IsNullOrEmpty(RequestId);
    }
}




// --- End of File ---

